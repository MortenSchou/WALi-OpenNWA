\section{Nested-Word Automata and Overview of the Library's Organization}
\label{Se:Nested Word Automata}

WALi-NWA is a library for constructing, querying, and operating on
nested-word automata.  It is a portion of the WALi library, which provides
types and operations for weighted automata.
It is implemented in C++.  The NWA portions of WALi
are largely logically separate from the rest of WALi, but WALi-NWA does use
facilities provided by WALi and inter-operates with WALi's weighted pushdown
system (WPDS) code.

We assume the reader is familiar with nested words and
nested-word automata; if not, \appref{nwa-definition} provides a definition and
Alur et al.~\cite{DLT:AM2006,JACM:AM2009} describe them in detail. Our
implementation corresponds to the definition from the DLT 2006
paper~\cite{DLT:AM2006}; relative to followup work~\cite{JACM:AM2009}, this definition removes
the distinction between the machine's linear and hierarchical states, and on
a call always stacks the source state. (In the JACM 2009 presentation of the
work, this would be called a ``weakly-hierarchical'' NWA.)

The terminology used in the interface of the package is geared
toward program analysis, so we use terms such as ``call site'' and ``return
site'' to refer to states of the NWA even though they take on different
meanings in different contexts.

The NWAs in this library have support for balanced and unbalanced-left nested
words only, and does not provide support for any words with pending
returns. (That is, we support balanced words and nested-word prefixes, but
not nested-word suffixes or general nested words.)



\subsection{Library overview}

The core of the NWA library is in the namespace \texttt{wali::nwa}. It
includes the classes \texttt{NestedWord}, \texttt{NWA}, and others.

There are a large number of non-member functions that operate on NWAs. These
are divided into three sub-namespaces:
\texttt{wali::nwa::query}, \texttt{wali::nwa::construct}, and
\texttt{wali::nwa::nwa\_pds}. There is also an experimental parser in
\texttt{wali::nwa}.

Finally, there are some operations and classes provided by WALi that the NWA
portion of the library uses. This mostly consists of the key-handling code,
but can also include the WPDS portions of the library.

Throughout this document, include paths are relative to the \texttt{Source}
directory from the WALi distribution.

\subsubsection{NWA core classes}

These types live in namespace \texttt{wali::nwa}:

\begin{description}
  \item[\texttt{NestedWord}] Models a single nested word. Currently the only
    operation that can be performed using one is to check whether a
    \texttt{NestedWord} is a member of an \texttt{NWA}'s language. (The word can be
    balanced or unbalanced, but bear in mind that our automata do not support
    pending returns.) To use, include \texttt{wali/nwa/NestedWord.hpp}.
  \item[\texttt{NWA}] Models a nested-word automaton. To use, include
    \texttt{wali/nwa/NWA.hpp}, or \texttt{wali/nwa/NWAFwd.hpp} if a
    definition is not needed. See
    \sectref{NWA-class}. (\sectref{serialization} also discusses a couple of
    functions related to serializing an NWA.)
  \item[\texttt{NWARefPtr}] \texttt{NWARefPtr} is a typedef of \texttt{ref\_ptr$<$NWA$>$} (see
    below). This is defined in \texttt{wali/nwa/NWAFwd.hpp}.
  \item[\texttt{State} and \texttt{Symbol}] These are both typedefs of
    \texttt{wali::Key} (see below). Both are defined in
    \texttt{wali/nwa/NWAFwd.hpp}.
  \item[\texttt{StateSet} and \texttt{SymbolSet}] These are typedefs of
    \texttt{std::set}s of the corresponding type. (Client code should not
    rely on this
    fact; it could change to be an \texttt{unordered\_map} or other similar
    container.) Both are defined in \texttt{wali/nwa/NWAFwd.hpp}.
  \item[\texttt{ClientInfo}] This class holds client-specific information that
    is associated with a state. Client code can subclass \texttt{ClientInfo} and use
    functions of the \texttt{NWA} class to attach instances to states. To use,
    include \texttt{wali/nwa/ClientInfo.hpp}. See \sectref{client-info}.
  \item[\texttt{WeightGen}] This abstract class describes how to assign weights
    to transitions of the NWA, and is used both when converting an NWA to a
    PDS and when doing prestar/poststar queries on the NWA directly. To use,
    include \texttt{wali/nwa/WeightGen.hpp}. See \sectref{NWAtoPDS}.
\end{description}


\subsubsection{NWA non-member functions}

The library provides a large number of non-member functions for operating on
NWAs. These are partitioned into the following namespaces:

\begin{description}
  \item[\texttt{wali::nwa::query}] This namespace provides functions for
    querying an automaton. The kinds of functions in this namespace are:
    \begin{itemize}
      \item Functions that query transitions of
        the NWA, returning information about one of the states or the symbol
        in transitions that meet some criteria. (For example, ``give me all
        states that appear as the target state of an internal transition with
        this source state.'') See \sectref{query-transitions}.
      \item Determining whether two NWAs have any states in
        common. See \sectref{query-automaton}.
      \item Determining whether an \texttt{NWA} is deterministic. See
        \sectref{query-automaton}.
      \item Determining whether a \texttt{NestedWord} is a member of the
        language of an NWA. See \sectref{query-language}.
      \item Determining whether the language of an NWA is empty. See
        \sectref{query-language}.
      \item Determining whether the languages of two NWAs are equal, or if
        one is a subset of the other. See \sectref{query-language}.
      \item prestar and poststar functions on an NWA. See
        \sectref{query-language}.
    \end{itemize}
    
  \item[\texttt{wali::nwa::construct}] This namespace provides functions for
    constructing an NWA. Functions in this namespace are standard,
    language-theoretic operations such as intersection, union, concatenation,
    Kleene star, and reversing. See \sectref{Building NWAs}.
  \item[\texttt{wali::nwa::nwa\_pds}] This namespace provides functions for
    converting between NWAs and PDSs, and related functions. (Note that
    construction of an NWA from a PDS is in this namespace, not in
    \texttt{construct}.) See \sectref{Conversions}.
  \item[\texttt{wali::nwa}] This namespace, in addition to the items already
    discussed, provides an experimental parser for a serialization format of
    NWAs. See \sectref{serialization}.
\end{description}


\subsubsection{Generic WALi}

The NWA library uses these portions of the standard WALi library. Unless
otherwise specified, they are in namespace \texttt{wali}. See \cite{wali}.

\begin{description}
  \item[\texttt{ref\_ptr$<$T$>$}] This is a reference-counted intrusive
    smart-pointer template. (``Intrusive'' means that the pointed-to type
    must be modified to include a \texttt{count} field used by the
    pointer. This is most conveniently done by subclassing
    \texttt{wali::Countable}.) Defined in \texttt{wali/ref\_ptr.hpp}.
  \item[\texttt{Key}] A \texttt{Key} is a unique identifier naming states and symbols in an
    NWA or NestedWord. It is actually a typedef of an integer, though client
    code should not rely on this precise type. \textsl{Note:} the use of keys for both
    states and symbols means that they can be confused from a types
    perspective, so use caution that this does not happen. Declared in
    \texttt{wali/Key.hpp}.
  \item[\texttt{getKey(...)}] This function produces a key from some input. If
    the input has not been seen before, it returns a new key; if it has, then
    it returns the same key as before. (One can think of this as translating
    whatever unique identifier is known by the client code to the
    \texttt{Key} needed by WALi.) Versions of this function are provided for
    the following types:
    \begin{itemize}
      \item \texttt{std::string const \&}
      \item \texttt{char *}
      \item \texttt{int}
      \item \texttt{std::set<Key> const \&}
      \item \texttt{Key, Key} (this is a two-argument version of
        \texttt{getKey})
      \item \texttt{key\_src\_t}
    \end{itemize}

    The final overload, for \texttt{key\_src\_t}, is a \texttt{ref\_ptr} to a
    \texttt{KeySource} object. \texttt{KeySource} is an abstract class that
    client code can subclass to provide a translation to \texttt{Key}s for
    arbitrary types.

    All overloads are declared in \texttt{wali/Key.hpp}.
  \item[\texttt{key2str}] \texttt{key2str} is an ``inverse'' of \texttt{getKey}, except that it
    always returns a string representation. If the key was created with the
    \texttt{getKey(std::string const \&)} overload in the first place, this
    returns a copy of the original string.\footnote{For \texttt{int}s, it is the
    textual representation of the original number. For a \texttt{set<Key>},
    it is the set printed in standard set notation. For a pair of keys, it is
    the pair printed as an ordered pair. In general, it is the result of
    calling \texttt{key\_src\_t::print}. See the \texttt{print} function in
    each of the files \texttt{wali/*Source.cpp}.} Declared in
    \texttt{wali/Key.hpp}.
  \item[\texttt{wali::wfa::WFA}] This is a weighted finite automaton. It is
    used in NWA poststar and prestar queries in much the same manner as in
    WPDS poststar and prestar queries. Defined in \texttt{wali/wfa/WFA.hpp}.
  \item[\texttt{wali::wpds::WPDS}] This is a weighted pushdown system. NWAs use
    WPDSs behind the scenes when doing poststar and prestar queries, and the
    library provides conversion routines between the two automata
    types. Defined in \texttt{wali/wpds/WPDS.hpp}.
\end{description}


