\section{The \texttt{NWA} class}
\label{Se:NWA-class}

\subsection{Construction, copying, and assignment}
\label{Se:Construction}

The NWA provides two constructors, the default constructor and the copy
constructor. The default constructor creates an empty NWA. Thereafter, 
client code can \begin{inparaenum} \item add or remove states, \item add or remove
symbols, \item add or remove transitions, \item set the status of certain
  states as initial or final, and \item combine component NWAs (via union,
  intersection, etc). \end{inparaenum}


The following functions are related to construction:
\begin{description}
  \item \texttt{NWA::NWA()}) constructs an empty NWA

  \item \texttt{NWA::NWA(NWA const \& other)} Copies \texttt{other}; the
    automata will not share structure

  \item \texttt{NWA::operator=(NWA const \& other)} Assigns \texttt{other} to \texttt{this};
    the automata will not share structure.

  \item \texttt{NWA::clear()} \nopagebreak
    Removes all states, symbols, and transitions from the NWA.

\end{description}


\subsection{Simple manipulations}

An NWA object tracks the set of states, symbols, and transitions in the
automaton. It also tracks the set of initial and accepting states.
Counting each kind of transition separately, this gives 7 kinds of
``entities'' that client code may need to manipulate.

For each kind of entity, there are \texttt{NWA} member functions to add and
remove a single entity, check whether a particular entity is in the
automaton, count the number of entities of a particular type, removing all
entities of a particular type, and retrieving the set of entities in the
NWA. In addition, there are member functions for counting and clearing all
transitions, regardless of of the type.

The names of these functions are very regular, but
\tableref{simple-functions} gives a list.

\newgeometry{bottom=0.70in,top=0.70in}
\begin{sidewaystable}\sffamily\footnotesize
\begin{threeparttable}
\begin{tabular}{p{0.75in}p{1.55in}p{1.6in}p{1.35in}p{1.27in}p{1.2in}p{1.5in}}
\toprule
                 &  add\tnote{1}                            &  remove\tnote{1}                          &  check membership\tnote{3} &  count                &  clear                     &  get\tnote{4}                 \\
\hline\hline %---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
states           &  addState(State st)                      &  removeState(State st)\tnote{5}           &  isState(State st)         &  sizeStates()         &  clearStates()\tnote{5}    &  getStates() or \newline
                                                                                                                                                                                             \{begin,end\}States()        \\
initial \newline
states           &  addInitialState(State st)               &  removeInitialState(State st)             &  isInitialState(State st)  &  sizeInitialStates()  &  clearInitialStates()      &  getInitialStates() or \newline
                                                                                                                                                                                             \{begin,end\}InitialStates() \\
final
\newline  states &  addFinalState(State st)                 &  removeFinalState(State st)               &  isFinalState(State)       &  sizeFinalStates()    &  clearFinalStates()        &  getFinalStates() or \newline
                                                                                                                                                                                             \{begin,end\}FinalStates()    \\
\hline %---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
symbols\tnote{2} &  addSymbol(Symbol sym)                   &  removeSymbol(Symbol sym)\tnote{5}        &  isSymbol(Symbol sym)      &  sizeSymbols()        &  clearSymbols()            &  getSymbols() or \newline
                                                                                                                                                                                             \{begin,end\}Symbols()         \\
\hline %---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
all \newline
transitions      &  ---                                     &  findTrans(State s1, Symbol sym, State s2)&  ---                       &  sizeTrans()          &  cleanTrans()              &  ---                           \\
internal \newline
transitions      &  addInternalTrans(\phantom{.}...\tnote{6}\phantom{a})
                                                            &  removeInternalTrans(\phantom{.}...\tnote{6}\phantom{a})
                                                                                                        &  ---                       &  sizeInternalTrans()  &  ---                       &  \{begin,end\}internalTrans()  \\
call \newline
transitions      &  addCallTrans(\phantom{.}...\tnote{6}\phantom{a})
                                                            &  removeCallTrans(\phantom{.}...\tnote{6}\phantom{a})
                                                                                                        &  ---                       &  sizeCallTrans()      &  ---                       &  \{begin,end\}callTrans()      \\
return \newline
transitions      &  addReturnTrans(\phantom{.}...\tnote{6}\phantom{a})
                                                            &  removeReturnTrans(\phantom{.}...\tnote{6}\phantom{a})
                                                                                                        &  ---                       &  sizeReturnTrans()  &  ---                       &  \{begin,end\}returnTrans()\\
\hline
\end{tabular}
\begin{tablenotes}
  \item[1] These functions return a \texttt{bool} indicating whether the item
    was added/removed. In addition, adding a transition implicitly adds all
    states and symbols in that transition if they are not already present.
  \item[2] \texttt{WALI\_EPSILON} and \texttt{WALI\_WILD} are not explicit
    members of the symbol set. This has the following consequences (for
    \texttt{s} as epsilon or wild): \texttt{addSymbol(s)} and
    \texttt{removeSymbol(s)} are both no-ops and return \texttt{false},
    \texttt{isSymbol(s)} returns false, \texttt{sizeSymbols()} does not count
    epsilon or wild, and neither the set returned by \texttt{getSymbols()}
    nor the iterator range \texttt{\{begin,end\}Symbols()} will contain
    epsilon or wild.
  \item[3] These functions return a \texttt{bool} with the natural
    interpretation.
  \item[4] The functions listed as, e.g., ``\{begin,end\}States()'' is a pair
    of functions each of which returns an iterator. The type of that iterator
    depends on the function, but is either a \texttt{NWA::StateIterator},
    \texttt{NWA::SymbolIterator}, \texttt{NWA::CallIterator},
    \texttt{NWA::InternalIterator}, or \texttt{NWA::ReturnIterator}. All are
    actually const iterators. The other functions (``get\textsl{Kind}()'')
    return a \texttt{StateSet} or \texttt{SymbolSet} as appropriate.
  \item[5] Removing a state or a symbol also removes all transitions
    involving it. (Hence clearing all states or clearing all symbols also
    clears all transitions.)
  \item[6] There are two overloads of each of these functions. The first
    takes each element of the transition tuple individually,
    e.g. \texttt{addInternalTrans(State src, State sym, State tgt)}. The
    second takes a (constant reference to a) \texttt{NWA::Internal},
    \texttt{NWA::Call}, or \texttt{NWA::Return} object (as
    appropriate). (These are typedefs of a \texttt{Triple} or \texttt{Quad}
    of the appropriate type.)
\end{tablenotes}
\caption{Table of several functions for accessing and maniuplating elements
  of NWAs. All are members of the \texttt{NWA} class. \TODO{Fix footnote
    numbering}}
\label{Ta:simple-functions}
\end{threeparttable}
\end{sidewaystable}
\restoregeometry

The only potential difficulties are in the interactions between the
functions. Naturally, removing a state or a symbol also removes all
transitions involving it; hence, clearing all states or clearing all symbols
also clears all transitions. (Removing an initial state or final state
does not cause rippling effects, however.)

Adding a transition implicitly adds the states and symbol involved in that
transition if they are not already present; hence it is not necessary to
explicitly add all states and symbols before adding transitions. (It is quite
reasonable to simply add accepting states, add final states, and add
transitions.)


The system supports two meta-symbols: \texttt{wali::WALI\_EPSILON}
(\texttt{$\epsilon$}) and \texttt{wali::WALI\_WILD} (\texttt{*}).
\texttt{WALI\_EPSILON} is the standard $\epsilon$ from automata theory; it
denotes the situation in which a transition can be traversed without matching
and consuming an input symbol.  Epsilon symbols cannot label call or return
transitions. \texttt{WALI\_WILD} is the `any' symbol; matches a single input
symbol of any kind.  Since the NWA alphabet is not fixed, the actual symbols
that \texttt{WALI\_WILD} stands for is fluid.  Note:
\textbf{\texttt{WALI\_EPSILON} and \texttt{WALI\_WILD} are not explicit
  elements of $\Sigma$.}



\subsection{Client Information}
\label{Se:client-info}

Each state in the NWA can be associated with some client-specific
information. To utilize this functionality, client code must subclass
\texttt{ClientInfo}. 

Once done, client information can be attached or retrieved using the
following two functions (both members of \texttt{NWA}):
\begin{description}
  \item\texttt{ref\_ptr<ClientInfo> getClientInfo( Key st ) const} \nopagebreak
    Allows the user to access the client-specific information associated with
    the given state, \texttt{st}.
  \item\texttt{void setClientInfo( Key st, ref\_ptr<ClientInfo> ci )} \nopagebreak
    Allows the user to specify the client-specific information, \texttt{ci},
    associated with the given state, \texttt{st}. \\
\end{description}
Client information is tracked through the use of \texttt{ref\_ptr}s, so the
programmer must be wary of aliasing and lifetime considerations.


In addition, you may wish to subclass \texttt{NWA} itself. There are several
virtual helper functions that are called during intersection and
determinization to compute the client info for the resulting automaton. These
can be overriden to customize the behavior. (This is a lightweight instance
of the ``template method'' design pattern.)

The list of these helper methods is:
\begin{itemize}
  \item \texttt{intersectClientInfoInternal}
  \item \texttt{intersectClientInfoCall}
  \item \texttt{intersectClientInfoReturn}
  \item \texttt{mergeClientInfo}
  \item \texttt{mergeClientInfoInternal}
  \item \texttt{mergeClientInfoCall}
  \item \texttt{mergeClientInfoReturn}
\end{itemize}
(The first 3 are used by intersection, and the remaining 4 by
determinization.) In addition, \texttt{stateIntersect} and
\texttt{transitionIntersect} can further customize the behavior of
intersection, including computation of client
information. \sectrefs{Intersection}{Determinize} have more information on
intersection and determinization, and discuss these functions further.



\subsection{The following are more functions that don't fit into the above categories}

\begin{description}
  \item\texttt{void duplicateState( Key orig, Key dup )} \nopagebreak

    Duplicates all the transitions containing the state \texttt{orig} and
    adds the transitions to the NWA with \texttt{orig} replaced by
    \texttt{dup}.  Self-loops are duplicated by adding a transition for all
    possible combinations of some occurrence of \texttt{orig} replaced by
    \texttt{dup}, i.e., if $(\texttt{orig},a,\texttt{orig})$ is an internal
    (or call) transition, then the transitions
    $(\texttt{dup},a,\texttt{dup})$, $(\texttt{dup},a,\texttt{orig})$, and
    $(\texttt{orig},a,\texttt{dup})$ are added and if
    $(\texttt{orig},\texttt{orig},a,\texttt{orig})$ is a return transition,
    then the transitions $(\texttt{dup},\texttt{dup},a,\texttt{dup})$,
    $(\texttt{dup},\texttt{dup},a,\texttt{orig})$,
    $(\texttt{orig},\texttt{dup},a,\texttt{dup})$,
    $(\texttt{orig},\texttt{dup},a,\texttt{orig})$,
    $(\texttt{dup},\texttt{orig},a,\texttt{dup})$,
    $(\texttt{dup},\texttt{orig},a,\texttt{orig})$, and
    $(\texttt{orig},\texttt{orig},a,\texttt{dup})$ are added.

  \item\texttt{void duplicateStateOutgoing( Key orig, Key dup )} \nopagebreak

    Duplicates all the transitions originating from \texttt{orig} and adds
    the transitions to the NWA with \texttt{orig} replaced by \texttt{dup}.
    Self-loops are duplicated by adding a transition for all possible
    combinations of some occurrence of \texttt{orig} replaced by \texttt{dup}
    while maintaining that the transitions are outgoing from \texttt{dup},
    i.e., if $(\texttt{orig},a,\texttt{orig})$ is an internal (or call)
    transition, then the transitions $(\texttt{dup},a,\texttt{dup})$ and
    $(\texttt{dup},a,\texttt{orig})$ are added and if
    $(\texttt{orig},\texttt{orig},a,\texttt{orig})$ is a return transition,
    then the transitions $(\texttt{dup},\texttt{dup},a,\texttt{dup})$,
    $(\texttt{dup},\texttt{dup},a,\texttt{orig})$,
    $(\texttt{dup},\texttt{orig},a,\texttt{dup})$, and
    $(\texttt{dup},\texttt{orig},a,\texttt{orig})$ are added.

  \item\texttt{void realizeImplicitTrans(State stuck)} \nopagebreak

    Makes the transition relation ``at least total.''
    Adds the state \texttt{stuck} to the machine (if not already present),
    then for any source state and symbol pair that does not have at least one
    transition, adds a transition to \texttt{stuck}. It does the same for
    call transitions and return transitions (with an additional ``for each
    call predecessor'' in that case).

    Note that if the machine was nondeterministic, it will still be
    nondeterministic after this call.

\end{description}
