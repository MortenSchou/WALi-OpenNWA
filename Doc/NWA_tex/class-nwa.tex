\section{The \texttt{NWA} class}
\label{Se:NWA-class}

\subsection{Construction, copying, and assignment}
\label{Se:Construction}

The NWA provides two constructors, the default constructor and the copy
constructor. The default constructor creates an empty NWA. Thereafter,
client code can add or remove states, add or remove symbols, add or remove
transitions, and set the status of certain states as initial or final.


The following functions are basic NWA operations:
\begin{functionlist}
  \functionitem[\texttt{NWA::NWA()}]
    Constructs an empty NWA.

  \functionitem[\texttt{NWA::NWA(NWA const \& other)}] Copies \texttt{other}; the
    automata will not share structure. Any client information that is present is cloned.

  \functionitem[\texttt{NWA::operator=(NWA const \& other)}] Assigns \texttt{other} to \texttt{this};
    the automata will not share structure.

  \functionitem[\texttt{NWA::clear()}] \nopagebreak
    Removes all states, symbols, and transitions from the NWA.

\end{functionlist}


\subsection{Simple manipulations}

An NWA object tracks the set of states, symbols, and transitions in the
automaton. It also tracks the set of initial and accepting states.
Counting each kind of transition separately, this gives 7 kinds of
``entities'' that client code may need to manipulate.

For each kind of entity, there are \texttt{NWA} member functions to add and
remove a single entity, check whether a particular entity is in the
automaton, count the number of entities of a particular type, remove all
entities of a particular type, and retrieve the set of entities in the
NWA. In addition, there are member functions for counting and clearing all
transitions, regardless of the type.

The names of these functions are very regular, but
\tableref{simple-functions} (\appref{Tables}) gives a list.

The only potential difficulties are in the interactions between the
functions. Naturally, removing a state or a symbol also removes all
transitions involving it; hence, clearing all states or clearing all symbols
also clears all transitions. (Calling \texttt{removeInitialState} or \texttt{removeFinalState}
does not cause ripple effects, however.)

Adding a transition implicitly adds the states and symbol involved in that
transition if they are not already present; hence it is not necessary to
explicitly add all states and symbols before adding transitions. (It is quite
reasonable to build an NWA by just adding initial states, final states, and
transitions.)


The system supports two meta-symbols: \texttt{wali::WALI\_EPSILON}
(\texttt{$\epsilon$}) and \texttt{wali::WALI\_WILD} (\texttt{\wild}).
\texttt{WALI\_EPSILON} is the standard $\epsilon$ from automata theory; it
denotes the situation in which a transition can be traversed without matching
and consuming an input symbol.  Epsilon symbols cannot label call or return
transitions. \texttt{WALI\_WILD} is the `any' symbol; it matches a single input
symbol of any kind.  Because the NWA alphabet is not fixed, the actual symbols
that \texttt{WALI\_WILD} stands for is fluid.  \textsl{Note:}
\texttt{WALI\_EPSILON} and \texttt{WALI\_WILD} are not explicit
elements of $\Sigma$; see \tableref{simple-functions}, footnote 5. \TODO{Fix
  footnote ref after modifying those in-table.}



\subsection{Client Information}
\label{Se:client-info}

Each state in the NWA can be associated with some client-specific
information. To utilize this functionality, client code must subclass
\texttt{ClientInfo} and override \texttt{ClientInfo * clone() const}.

Once done, client information can be attached or retrieved using the
following two functions (both members of \texttt{NWA}):
\begin{functionlist}
  \functionitem[\texttt{ref\_ptr<ClientInfo> NWA::getClientInfo( Key st ) const}]
    Allows the user to access the client-specific information associated with
    the given state, \texttt{st}.
  \functionitem[\texttt{void NWA::setClientInfo( Key st, ref\_ptr<ClientInfo> ci )}]
    Allows the user to specify the client-specific information, \texttt{ci},
    associated with the given state, \texttt{st}. \\
\end{functionlist}
Client information is tracked through the use of \texttt{ref\_ptr}s, so the
programmer must consider the standard aliasing and lifetime considerations
imposed by using smart pointers.

\vspace{\baselineskip}
In addition, you may wish to subclass \texttt{NWA} itself. There are several
virtual helper functions that are called during intersection and
determinization to compute the client info for the resulting automaton; these
can be overriden to customize the behavior. (This design is an instance
of the ``template method'' design pattern.)

The list of these helper methods is:
\begin{itemize}
  \item \texttt{intersectClientInfoInternal}
  \item \texttt{intersectClientInfoCall}
  \item \texttt{intersectClientInfoReturn}
  \item \texttt{mergeClientInfo}
  \item \texttt{mergeClientInfoInternal}
  \item \texttt{mergeClientInfoCall}
  \item \texttt{mergeClientInfoReturn}
\end{itemize}
(The first three are used by intersection and the remaining four by
determinization.) In addition, \texttt{stateIntersect} and
\texttt{transitionIntersect} can further customize the behavior of
intersection, including computation of client
information. \sectrefs{Intersection}{Determinize} have more information on
intersection and determinization, and discuss these functions further.


\begin{comment}

\subsection{The following are more functions that don't fit into the above categories}

\begin{functionlist}
  \functionitem[\texttt{void NWA::duplicateState( Key orig, Key dup )}] \nopagebreak

    Duplicates all the transitions containing the state \texttt{orig} and
    adds the transitions to the NWA with \texttt{orig} replaced by
    \texttt{dup}.  Self-loops are duplicated by adding a transition for all
    possible combinations of some occurrence of \texttt{orig} replaced by
    \texttt{dup}, i.e., if $(\texttt{orig},a,\texttt{orig})$ is an internal
    (or call) transition, then the transitions
    $(\texttt{dup},a,\texttt{dup})$, $(\texttt{dup},a,\texttt{orig})$, and
    $(\texttt{orig},a,\texttt{dup})$ are added and if
    $(\texttt{orig},\texttt{orig},a,\texttt{orig})$ is a return transition,
    then the transitions $(\texttt{dup},\texttt{dup},a,\texttt{dup})$,
    $(\texttt{dup},\texttt{dup},a,\texttt{orig})$,
    $(\texttt{orig},\texttt{dup},a,\texttt{dup})$,
    $(\texttt{orig},\texttt{dup},a,\texttt{orig})$,
    $(\texttt{dup},\texttt{orig},a,\texttt{dup})$,
    $(\texttt{dup},\texttt{orig},a,\texttt{orig})$, and
    $(\texttt{orig},\texttt{orig},a,\texttt{dup})$ are added.

  \functionitem[\texttt{void NWA::duplicateStateOutgoing( Key orig, Key dup )}] \nopagebreak

    Duplicates all the transitions originating from \texttt{orig} and adds
    the transitions to the NWA with \texttt{orig} replaced by \texttt{dup}.
    Self-loops are duplicated by adding a transition for all possible
    combinations of some occurrence of \texttt{orig} replaced by \texttt{dup}
    while maintaining that the transitions are outgoing from \texttt{dup},
    i.e., if $(\texttt{orig},a,\texttt{orig})$ is an internal (or call)
    transition, then the transitions $(\texttt{dup},a,\texttt{dup})$ and
    $(\texttt{dup},a,\texttt{orig})$ are added and if
    $(\texttt{orig},\texttt{orig},a,\texttt{orig})$ is a return transition,
    then the transitions $(\texttt{dup},\texttt{dup},a,\texttt{dup})$,
    $(\texttt{dup},\texttt{dup},a,\texttt{orig})$,
    $(\texttt{dup},\texttt{orig},a,\texttt{dup})$, and
    $(\texttt{dup},\texttt{orig},a,\texttt{orig})$ are added.

  \functionitem[\texttt{void NWA::realizeImplicitTrans(State stuck)}] \nopagebreak

    Makes the transition relation ``at least total.''
    For any source state and symbol pair that does not have at least one
    transition, adds a transition to \texttt{stuck}. It does the same for
    call transitions and return transitions (with an additional ``for each
    call predecessor'' for returns).

    Note that if the machine was nondeterministic, it will still be
    nondeterministic after this call.

\end{functionlist}

\end{comment}
