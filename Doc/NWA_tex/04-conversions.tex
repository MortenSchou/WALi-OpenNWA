\section{Conversions beween WPDS and NWA (namespace
  \texttt{wali::nwa::nwa\_pds})}
\label{Se:Conversions}


It is possible to convert a WALi WPDS to an NWA and vice versa.
However, the construction of an NWA from a WPDS is not the inverse
of constructing a WPDS from an NWA, i.e., one cannot perform the two
conversions in sequence and obtain the identity conversion.

At a high level, the WPDS to NWA conversion works by making the NWA encode both the state
of the WPDS and its top-of-stack symbol. A WPDS rule of the form $\langle
p,q_1 \rangle \hookrightarrow \langle p,q_2 \rangle$ leaves the stack height
unchanged, and thus is associated with an internal NWA transition; in this
case, that transition goes from the state $(p,q_1)$ to $(p,q_2)$. The symbol
of a transition is associated with the top-of-stack symbol of the source
state, so in this example, the symbol labeling that transition would be
$q_1$. WPDS push rules correspond to NWA call transitions, and WPDS pop rules
correspond to NWA return transitions.\footnote{
This encoding is motivated by our uses of both WPDSs and NWAs in program
analysis. It is common for WPDSs to have just one state, $p$, and to use the
top-of-stack symbol to encode the ``current'' program point. Pushing
something onto the stack corresponds to a call, and popping corresponds to a
return. For NWAs, we use the states themselves to encode the current program
point. (The function that
converts a WPDS into an NWA supports multi-state WPDSs, however; the fact that
there is typically a single state is not a restriction.)}

The conversion in the other direction creates a WPDS with one primary state
and one ``helper'' state for each NWA state that appears in the exit position
of a return transition. The NWA's state is ``moved'' to the top state of the
stack -- essentially the inverse of the encoding described in the previous
paragraph. A slight complication arises in the case of return
transitions. The NWA is able to look at both the exit node and the call
predecessor. In the WPDS this translates to looking at the top two stack
symbols -- but this is not allowed. Hence each NWA return transition becomes
two WPDS rules; the first pops the top symbol (which corresponds to the
current NWA state) and remembers what it was using the helper state; the
second rule looks at the call predecessor and the helper state to dispatch to
the corresponding return site.

The library also offers two slight variants on this conversion.First, there
is a backwards variant that can be used for backwards flow analysis
problems. Second, the resulting WPDS can stack either calls or returns. The
``stacking calls'' version turns call transitions $(q, \sigma, q')$ into a
WPDS rule $\langle p, q\rangle \hookrightarrow \langle p, q' q\rangle$ --
leaving the call predecessor on the stack. (This is like the version
described in the previous paragraph.) The ``stacking returns'' version
instead makes several WPDS push rules for each NWA call transition. Each
push rule leaves a potential return site on the stack. (For example, if there
is a call transition $(c,\sigma,e)$ and a return transition $(x, c, \sigma',
r)$, then the WPDS will have a rule $\langle p,
c\rangle\hookrightarrow\langle p, e r\rangle$.


The following functions are in the namespace \texttt{wali::nwa::nwa\_pds} and
are declared in the header \texttt{wali/nwa/nwa\_pds/conversions.hpp}.


\begin{functionlist}
  \functionitem[\texttt{void WpdsToNwa( NWA \& out, const WPDS\& pds )}] \nopagebreak
  \functionitem[\texttt{NWARefPtr WpdsToNwa( NWA const \& nwa, const WPDS\& pds )}] \nopagebreak
    Converts \texttt{pds} to an NWA, either storing the result in
    \texttt{nwa} or returning it.

  \functionitem[\texttt{WPDS NwaToWpdsCalls( NWA const \& nwa, WeightGen<Client>\& wg ) const}] \nopagebreak
  \functionitem[\texttt{WPDS NwaToBackwardsWpdsCalls( NWA const \& nwa, WeightGen<Client>\& wg )}] \nopagebreak
  \functionitem[\texttt{WPDS NwaToWpdsReturns( NWA const \& nwa, WeightGen<Client>\& wg ) const}] \nopagebreak
  \functionitem[\texttt{WPDS NwaToBackwardsWpdsReturns( NWA const \& nwa, WeightGen<Client>\& wg )}] \nopagebreak
    Constructs the WPDS that is equivalent to \texttt{nwa} using the
    appropriate method (backwards or forwards flow, and stacking calls or
    stacking returns), returning the result. Uses \texttt{wg} to determine
    weights for the WPDS's transitions.

  \functionitem[\texttt{WPDS plusWPDS( NWA const \& nwa, const WPDS\& base )}] \nopagebreak

    This returns the WPDS that is the
    product of \texttt{nwa} and the given WPDS
    \cite{advancedquerying}.
\end{functionlist}


\subsection{WPDS to NWA}
\label{Se:WpdsToNwa}

The \texttt{WpdsToNwa} functions convert a WPDS into an NWA in a manner
faithful to the encoding suggested in the introduction to this section.

Assume that we have a WPDS $(P, \Gamma, \Delta )$ 
where $\Delta = (\Delta_0, \Delta_1, \Delta_2)$. This 
WPDS is converted into an NWA using the following rules:

\begin{mathpar}
{\inferrule*[left=\textsc{States}]
  { p \in P \\ q \in \Gamma }
  { (p,q) \in Q }
}
\and
{\inferrule*[left=\textsc{Alphabet}]
  { q \in \Gamma }
  { q \in \Sigma } 
}
\and 
\\
{\inferrule*[left=\textsc{Internal}]
  { \langle p,q \rangle \hookrightarrow \langle p',q' \rangle \in  \Delta_1 }
  { ( (p,q), q, (p',q') ) \in \delta_i  }
}
\and
{\inferrule*[left=\textsc{Call}]
  { \langle p,q_c \rangle \hookrightarrow \langle  p',q_e \hspace{.1cm} q_r \rangle \in \Delta_2 }
  { ( (p,q_c), q_c, (p',q_e) ) \in \delta_c }
} 
\and
{\inferrule*[left=\textsc{Return}]
  { \langle p'',q_x \rangle \hookrightarrow \langle p''',\epsilon  \rangle \in \Delta_0 \\
     \langle p,q_c \rangle \hookrightarrow \langle p',q_e \hspace{.1cm} q_r  \rangle \in \Delta_2 }
  { ( (p'',q_x), (p,q_c), q_x, (p''',q_r) ) \in \delta_r }
}
\end{mathpar}

Note that we will generate an NWA return transition for each pair of WPDS pop
and push rules; there is no constraint between the two rules.  This is
because, with the exception of the ``revealed'' stack symbol $q_r$,
everything that the push rule talks about concerns the call predecessor
$(p,q_c)$ and entry node $(q', q_e)$; nothing the pop rule talks about --
$p''$, $q_x$, or $p'''$ -- has any relation to those.


In the resulting NWA, $Q_0$ and $Q_f$ are empty; client code must set the initial and
final states as appropriate (with \texttt{addInitialState(State s)} and
\texttt{addFinalState(State s)}. The keys that generated for the names of the
NWA states are part of the interface of this function; they are generated by
\texttt{getKey(p, q)} where \texttt{p} and \texttt{q} are the keys of the
WPDS state and stack symbol being converted.


\begin{figure}[t]
  \centering
    \begin{itemize}
      \centering
      \item{ $\langle p,main \rangle \hookrightarrow \langle p,q_1 \rangle$}
      \item{ $\langle p,q_1 \rangle \hookrightarrow \langle p,c_1 \rangle$}
      \item{ $\langle p,c_1 \rangle \hookrightarrow \langle p,e \hspace{.1cm} r_1 \rangle$}
      \item{ $\langle p,e \rangle \hookrightarrow \langle p,q_2 \rangle$}
      \item{ $\langle p,q_2 \rangle \hookrightarrow \langle p,q_3 \rangle$}
      \item{ $\langle p,q_3 \rangle \hookrightarrow \langle p,x \rangle$}
      \item{ $\langle p,x \rangle \hookrightarrow \langle p,\epsilon \rangle$}
      \item{ $\langle p,r_1 \rangle \hookrightarrow \langle p,q_4 \rangle$}
      \item{ $\langle p,q_4 \rangle \hookrightarrow \langle p,q_5 \rangle$}
      \item{ $\langle p,q_5 \rangle \hookrightarrow \langle p,c_2 \rangle$}
      \item{ $\langle p,c_2 \rangle \hookrightarrow \langle p,e \hspace{.1cm} r_2 \rangle$}
      \item{ $\langle p,r_2 \rangle \hookrightarrow \langle p,q_6 \rangle$}
      \item{ $\langle p,q_6 \rangle \hookrightarrow \langle p,exit \rangle$}
    \end{itemize}
  \caption{An example WPDS.}
  \label{Fi:WpdsToNwa1}
\end{figure}

For example, the NWA resulting from converting the WPDS shown in
\figref{WpdsToNwa1} into an NWA is shown in \figref{WpdsToNwa2}.

\begin{figure}[t]
  \centering
    \nwaimage[1]{Figures/pds-equivalent}
  \caption{The NWA resulting from converting the WPDS in \figref{WpdsToNwa1} into an NWA.}
  \label{Fi:WpdsToNwa2}
\end{figure}


The client information for all states in the resulting NWA are set to \texttt{null}.


\subsection{NWA to WPDS}
\label{Se:NWAtoPDS}


An NWA can also be converted into a WPDS.  In this way it is possible to use
the WPDS reachability queries that are a part of the main WALi library on
NWAs.  As mentioned in the introduction to \sectref{Conversions}, there are
four variations on the NWA to WPDS conversion: forward flow with call states
on the stack, backward flow with call states on the stack, forward flow with
return states on the stack, and backward flow with return states on the
stack. All four variations use \texttt{WeightGen} to determine weights for
WPDS rules.

\texttt{WeightGen} is an abstract class that client code must subclass to
calculate the weights of the rules in the generated WPDS.  It allows the
underlying NWA to be decoupled from the weight domain used in the WPDS.  See
\cite[\S4-\S5]{wali} for details about weight domains.


\begin{figure}[p]
  \centering
  \begin{minipage}{\textwidth}
    \nwaimage[1]{Figures/pre-pds-nwa}
    \caption{An example NWA.}
    \label{Fi:NwaToWpds1}
  \end{minipage}
  \begin{minipage}{0.42\textwidth}
    \begin{itemize}
      \centering
      \item{ $\langle p,main \rangle \hookrightarrow \langle p,q_1 \rangle$}
      \item{ $\langle p,q_1 \rangle \hookrightarrow \langle p,c_1 \rangle$}
      \item{ $\langle p,e \rangle \hookrightarrow \langle p,q_2 \rangle$}
      \item{ $\langle p,q_2 \rangle \hookrightarrow \langle p,q_3 \rangle$}
      \item{ $\langle p,q_3 \rangle \hookrightarrow \langle p,x \rangle$}
      \item{ $\langle p,r_1 \rangle \hookrightarrow \langle p,q_4 \rangle$}
      \item{ $\langle p,q_4 \rangle \hookrightarrow \langle p,q_5 \rangle$}
      \item{ $\langle p,q_5 \rangle \hookrightarrow \langle p,c_2 \rangle$}
      \item{ $\langle p,r_2 \rangle \hookrightarrow \langle p,q_6 \rangle$}
      \item{ $\langle p,q_6 \rangle \hookrightarrow \langle p,exit \rangle$}
      \item{ $\langle p,c_1 \rangle \hookrightarrow \langle p,e \hspace{.1cm} c_1 \rangle$}
      \item{ $\langle p,c_2 \rangle \hookrightarrow \langle p,e \hspace{.1cm} c_2 \rangle$}
      \item{ $\langle p,x \rangle \hookrightarrow \langle p_x, \epsilon \rangle$}
      \item{ $\langle p_x,c_1 \rangle \hookrightarrow \langle p,r_1 \rangle$}
      \item{ $\langle p,x \rangle \hookrightarrow \langle p_x, \epsilon \rangle$}
      \item{ $\langle p_x,c_2 \rangle \hookrightarrow \langle p,r_2 \rangle$}
    \end{itemize}
    \caption{The WPDS resulting from calling \texttt{NwaToWpdsCalls} on \figref{NwaToWpds1}}
    \label{Fi:NwaToWpds4}
  \end{minipage}
  \hspace{0.1\textwidth}
  \begin{minipage}{0.42\textwidth}
    \centering
    \begin{itemize}
      \centering
      \item{ $\langle p,q_1 \rangle \hookrightarrow \langle p,main \rangle$}
      \item{ $\langle p,c_1 \rangle \hookrightarrow \langle p,q_1 \rangle$}
      \item{ $\langle p,q_2 \rangle \hookrightarrow \langle p,e \rangle$}
      \item{ $\langle p,q_3 \rangle \hookrightarrow \langle p,q_2 \rangle$}
      \item{ $\langle p,x \rangle \hookrightarrow \langle p,q_3 \rangle$}
      \item{ $\langle p,q_4 \rangle \hookrightarrow \langle p,r_1 \rangle$}
      \item{ $\langle p,q_5 \rangle \hookrightarrow \langle p,q_4 \rangle$}
      \item{ $\langle p,c_2 \rangle \hookrightarrow \langle p,q_5 \rangle$}
      \item{ $\langle p,q_6 \rangle \hookrightarrow \langle p,r_2 \rangle$}
      \item{ $\langle p,exit \rangle \hookrightarrow \langle p,q_6 \rangle$}
      \item{ $\langle p,r_1 \rangle \hookrightarrow \langle p,x \hspace{.1cm} r_1 \rangle$}
      \item{ $\langle p,r_2 \rangle \hookrightarrow \langle p,x \hspace{.1cm} r_2 \rangle$}
      \item{ $\langle p,e \rangle \hookrightarrow \langle p_e, \epsilon \rangle$}
      \item{ $\langle p_e,r_1 \rangle \hookrightarrow \langle p,c_1 \rangle$}
      \item{ $\langle p,e \rangle \hookrightarrow \langle p_e, \epsilon \rangle$}
      \item{ $\langle p_e,r_2 \rangle \hookrightarrow \langle p,c_2 \rangle$}
    \end{itemize}
    \caption{The result of calling \texttt{NwaToBackwardsWpdsCalls} on \figref{NwaToWpds1}}
    \label{Fi:NwaToWpds5}
  \end{minipage}
  \begin{minipage}{0.42\textwidth}
    \centering
    \begin{itemize}
      \centering
      \item{ $\langle p,main \rangle \hookrightarrow \langle p,q_1 \rangle$}
      \item{ $\langle p,q_1 \rangle \hookrightarrow \langle p,c_1 \rangle$}
      \item{ $\langle p,e \rangle \hookrightarrow \langle p,q_2 \rangle$}
      \item{ $\langle p,q_2 \rangle \hookrightarrow \langle p,q_3 \rangle$}
      \item{ $\langle p,q_3 \rangle \hookrightarrow \langle p,x \rangle$}
      \item{ $\langle p,r_1 \rangle \hookrightarrow \langle p,q_4 \rangle$}
      \item{ $\langle p,q_4 \rangle \hookrightarrow \langle p,q_5 \rangle$}
      \item{ $\langle p,q_5 \rangle \hookrightarrow \langle p,c_2 \rangle$}
      \item{ $\langle p,r_2 \rangle \hookrightarrow \langle p,q_6 \rangle$}
      \item{ $\langle p,q_6 \rangle \hookrightarrow \langle p,exit \rangle$}
      \item{ $\langle p,c_1 \rangle \hookrightarrow \langle p,e \hspace{.1cm} r_1 \rangle$}
      \item{ $\langle p,c_2 \rangle \hookrightarrow \langle p,e \hspace{.1cm} r_2 \rangle$}
      \item{ $\langle p,x \rangle \hookrightarrow \langle p_x, \epsilon \rangle$}
      \item{ $\langle p_x,r_1 \rangle \hookrightarrow \langle p,r_1 \rangle$}
      \item{ $\langle p,x \rangle \hookrightarrow \langle p_x, \epsilon \rangle$}
      \item{ $\langle p_x,r_2 \rangle \hookrightarrow \langle p,r_2 \rangle$}
    \end{itemize}
    \caption{The WPDS resulting from calling \texttt{NwaToWpdsReturns} on \figref{NwaToWpds1}}
    \label{Fi:NwaToWpds2}
  \end{minipage}
  \hspace{0.1\textwidth}
  \begin{minipage}{0.42\textwidth}
    \centering
    \begin{itemize}
      \centering
      \item{ $\langle p,q_1 \rangle \hookrightarrow \langle p,main \rangle$}
      \item{ $\langle p,c_1 \rangle \hookrightarrow \langle p,q_1 \rangle$}
      \item{ $\langle p,q_2 \rangle \hookrightarrow \langle p,e \rangle$}
      \item{ $\langle p,q_3 \rangle \hookrightarrow \langle p,q_2 \rangle$}
      \item{ $\langle p,x \rangle \hookrightarrow \langle p,q_3 \rangle$}
      \item{ $\langle p,q_4 \rangle \hookrightarrow \langle p,r_1 \rangle$}
      \item{ $\langle p,q_5 \rangle \hookrightarrow \langle p,q_4 \rangle$}
      \item{ $\langle p,c_2 \rangle \hookrightarrow \langle p,q_5 \rangle$}
      \item{ $\langle p,q_6 \rangle \hookrightarrow \langle p,r_2 \rangle$}
      \item{ $\langle p,exit \rangle \hookrightarrow \langle p,q_6 \rangle$}
      \item{ $\langle p,r_1 \rangle \hookrightarrow \langle p,x \hspace{.1cm} c_1 \rangle$}
      \item{ $\langle p,r_2 \rangle \hookrightarrow \langle p,x \hspace{.1cm} c_2 \rangle$}
      \item{ $\langle p,e \rangle \hookrightarrow \langle p_e, \epsilon \rangle$}
      \item{ $\langle p_e,c_1 \rangle \hookrightarrow \langle p,c_1 \rangle$}
      \item{ $\langle p,e \rangle \hookrightarrow \langle p_e, \epsilon \rangle$}
      \item{ $\langle p_e,c_2 \rangle \hookrightarrow \langle p,c_2 \rangle$}
    \end{itemize}
    \caption{The result of calling \texttt{Nwa\-To\-Backwards\-Wpds\-Returns} on \figref{NwaToWpds1}}
    \label{Fi:NwaToWpds3}
  \end{minipage}
\end{figure}


The following operations are virtual methods of class WeightGen intended to
be overridden:

\begin{functionlist} 
  \functionitem[\texttt{sem\_elem\_t getOne()} const = 0]  \nopagebreak
    Returns an instance of the $\bar{1}$ element of the weight domain.

  \functionitem[\texttt{sem\_elem\_t getWeight(
      \parbox[t]{4in}{
        State source, ClientInfoRefPtr sourceInfo, \\  
        Symbol symbol, Kind k, \\
        State target, ClientInfoRefPtr targetInfo ) const}}]  \nopagebreak
    Computes and returns the weight for the rule corresponding to the
    transition from \texttt{source} to \texttt{target} (of
    \texttt{kind})
    labeled with symbol \texttt{symbol}. By default, returns texttt{getOne()}.

  \functionitem[\texttt{sem\_elem\_t getWildWeight( \\
      \parbox[t]{4in}{
        State source, ClientInfoRefPtr sourceInfo, \\  
        State target, ClientInfoRefPtr targetInfo ) const}}]  \nopagebreak
    Computes and returns the weight for the WPDS rule corresponding to the
    transition from \texttt{source} to \texttt{target} labeled with the
    meta-symbol \wild. By default, returns texttt{getOne()}.

  \functionitem[\texttt{sem\_elem\_t getExitWeight(State src, ClientInfoRefPtr srcInfo)} const]
  This method computes the weight(in the desired semiring) for the return rule of
  the WPDS corresponding to the exit 'src'.
  Note: value is generally the same as \texttt{getOne()}, which is what the
  default implementation returns.

\end{functionlist}


\subsubsection{1. Forwards Flow Stacking Calls}

\noindent The conversion is performed by:



\begin{mathpar}

{\inferrule*%%[left=\textsc{States}]
  { }
  {p \in P}
}
\and 
{\inferrule*
  { (q_x,q_c,\sigma,q_r) \in \delta_r }
  { p_{q_x} \in P }
}
\and
{\inferrule*
  { q \in Q }
  { q \in \Gamma }
}
\and 
{\inferrule*%%[left=\textsc{Internal}]
  { (q,\sigma,q') \in \delta_i }
  { \langle p,q \rangle \stackrel{w_1}{\hookrightarrow} \langle p,q' \rangle \in \Delta_1 }
}
\and
{\inferrule*%%[left=\textsc{Call}]
  { (q_c,\sigma, q_e) \in \delta_c }
  {  \langle p,q_c \rangle \stackrel{w_2}{\hookrightarrow} \langle p, q_e \hspace{.1cm} q_c \rangle\in \Delta_2 }
}
\and
{\inferrule*%%[left=\textsc{Return}]
  { (q_x,q_c,\sigma,q_r) \in \delta_r }
  { \langle p,q_x \rangle \stackrel{w_0}{\hookrightarrow} \langle p_{q_x},\epsilon \rangle \in \Delta_0 \\
   \langle p_{q_x},q_c \rangle \stackrel{w_3}{\hookrightarrow} \langle p,q_r \rangle\in \Delta_1  }
}
\end{mathpar}
\begin{align*}
\text{where }
w_0 & = \begin{cases}
        \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
        \mathtt{wg.getWildWeight}(q,CI_q,q',CI_{q'}), & \text{if } \sigma = \text{\wild} \\
        \mathtt{wg.getWeight}(q_x,CI_{q_x},\sigma,\mathtt{EXIT\_TO\_RET},q_r,CI_{q_r}), & \text{otherwise}
      \end{cases}  \\
w_1 &= \begin{cases}
         \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
         \mathtt{wg.getWildWeight}(q,CI_q,q',CI_{q'}), & \text{if } \sigma = \text{\wild} \\
         \mathtt{wg.getWeight}(q,CI_q,\sigma,\mathtt{INTRA},q',CI_{q'}), & \text{otherwise}
      \end{cases} \\
w_2 &= \begin{cases}
         \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
         \mathtt{wg.getWildWeight}(q,CI_q,q',CI_{q'}), & \text{if } \sigma = \text{\wild} \\
         \mathtt{wg.getWeight}(q_c,CI_{q_c},\sigma,\mathtt{CALL\_TO\_ENTRY},q_e,CI_{q_e}), & \text{otherwise}
      \end{cases} \\
w_3 &= \mathtt{wg.getOne}() 
\end{align*}


For example, the WPDS resulting from converting the NWA
shown in \figref{NwaToWpds1} into a WPDS is shown in
\figref{NwaToWpds4}. \\


\subsubsection{2. Backwards Flow Stacking Calls}

\noindent The conversion is performed by:



\begin{mathpar}
{\inferrule*%%[left=\textsc{States}]
  { }
  {p \in P}
}
\and 
{\inferrule*
  { (q_c,\sigma,q_e) \in \delta_c }
  { p_{q_e} \in P }
}
\and
{\inferrule*
  { q \in Q }
  { q \in \Gamma }
}
\and 
{\inferrule*%%[left=\textsc{Internal}]
  { (q,\sigma,q') \in \delta_i }
  { \langle p,q' \rangle \stackrel{w_1}{\hookrightarrow} \langle p,q \rangle \in \Delta_1 }
}
\and  
{\inferrule*%%[left=\textsc{Call}]
  { (q_c,\sigma, q_e) \in \delta_c \\ (q_x,q_c,\gamma,q_r) \in \delta_r }
  { \langle p,q_e \rangle \stackrel{w_0}{\hookrightarrow} \langle p_{q_e},\epsilon \rangle \in \Delta_0 \\
    \langle p_{q_e},q_r \rangle \stackrel{w_3}{\hookrightarrow} \langle p,q_c  \rangle \in \Delta_1 }
}
\and
{\inferrule*%%[left=\textsc{Return}]
  { (q_x,q_c,\sigma,q_r) \in \delta_r }
  {  \langle p,q_r \rangle \stackrel{w_2}{\hookrightarrow} \langle p,q_x \hspace{.1cm} q_r
  \rangle \in \Delta_2 }
}
\end{mathpar}
\begin{align*}
\text{where }
w_0 &= \begin{cases}
           \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
           \mathtt{wg.getWildWeight}(q_c,CI_{q_c},q_e,CI_{q_e}), & \text{if } \sigma = \text{\wild} \\
           \mathtt{wg.getWeight}(q_c,CI_{q_c},\sigma, \mathtt{CALL\_TO\_ENTRY},q_e,CI_{q_e}), & \text{otherwise}
      \end{cases} \\
w_1 &= \begin{cases}
           \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
           \mathtt{wg.getWildWeight}(q,CI_q,q',CI_{q'}), & \text{if } \sigma = \text{\wild} \\
           \mathtt{wg.getWeight}(q,CI_q,\sigma, \mathtt{INTRA},q',CI_{q'}), & \text{otherwise}
       \end{cases} \\
w_2 &= \begin{cases}
          \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
          \mathtt{wg.getWildWeight}(q_x,CI_{q_x},q_r,CI_{q_r}), & \text{if } \sigma = \text{\wild} \\
          \mathtt{wg.getWeight}(q_x,CI_{q_x},\sigma, \mathtt{EXIT\_TO\_RET},q_r,CI_{q_r}), & \text{otherwise}
      \end{cases} \\
w_3 &= \mathtt{wg.getOne}()
\end{align*}




\noindent Consider, as an example, converting the NWA in
\figref{NwaToWpds1} into a backwards flow WPDS.  The WPDS resulting from
converting the NWA shown in \figref{NwaToWpds1} into a backwards flow
WPDS is shown in \figref{NwaToWpds5}.  Note:
\texttt{NWAtoBackwardsPDScalls(A)} = \texttt{NwaToWpdscalls(reverse(A))}.  \\

\subsubsection{3. Forwards Flow Stacking Returns}

\noindent The conversion is performed by:


\begin{mathpar}
{\inferrule*%%[left=\textsc{States}]
  { }
  {p \in P}
}
\and 
{\inferrule*
  { (q_x,q_c,\sigma,q_r) \in \delta_r }
  { p_{q_x} \in P }
}
\and
{\inferrule*
  { q \in Q }
  { q \in \Gamma }
}
\and 
{\inferrule*%%[left=\textsc{Internal}]
  { (q,\sigma,q') \in \delta_i }
  { \langle p,q  \rangle \stackrel{w_1}{\hookrightarrow} \langle p,q' \rangle \in \Delta_1 }
}
\and
{\inferrule*%%[left=\textsc{Call}]
  { (q_c,\sigma, q_e) \in \delta_c \\ (q_x,q_c,\gamma,q_r) \in \delta_r }
  { \langle p,q_c \rangle \stackrel{w_2}{\hookrightarrow}  \langle p, q_e \hspace{.1cm} q_r \rangle \in \Delta_2 }
}
\and 
{\inferrule*%%[left=\textsc{Return}]
  { (q_x,q_c,\sigma,q_r) \in \delta_r }
  { \langle p,q_x \rangle \stackrel{w_0}{\hookrightarrow} \langle p_{q_x},\epsilon \rangle \in  \Delta_0 \\
    \langle  p_{q_x},q_r \rangle \stackrel{w_3}{\hookrightarrow} \langle p,q_r \rangle \in \Delta_1 }
}
\end{mathpar}
\begin{align*}
\text{where }
w_0 &= \mathtt{wg.getOne}() \\
w_1 &= \begin{cases}
           \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
           \mathtt{wg.getWildWeight}(q,CI_q,q',CI_{q'}), & \text{if } \sigma = \text{\wild} \\
           \mathtt{wg.getWeight}(q,CI_q,\sigma, \mathtt{INTRA},q',CI_{q'}), & \text{otherwise}
       \end{cases} \\
w_2 &= \begin{cases}
           \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
           \mathtt{wg.getWildWeight}(q_c,CI_{q_c},q_e,CI_{q_e}), & \text{if } \sigma = \text{\wild} \\
           \mathtt{wg.getWeight}(q_c,CI_{q_c},\sigma, \mathtt{CALL\_TO\_ENTRY},q_e,CI_{q_e}), & \text{otherwise}
      \end{cases} \\
w_3 &= \begin{cases}
          \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
          \mathtt{wg.getWildWeight}(q_x,CI_{q_x},q_r,CI_{q_r}), & \text{if } \sigma = \text{\wild} \\
          \mathtt{wg.getWeight}(q_x,CI_{q_x},\sigma, \mathtt{EXIT\_TO\_RET},q_r,CI_{q_r}), & \text{otherwise}
      \end{cases} 
\end{align*}


\noindent Consider, as an example, converting the NWA in
\figref{NwaToWpds1} into a WPDS.  The WPDS resulting from converting the WPDS
shown in \figref{NwaToWpds1} into a WPDS is shown in
\figref{NwaToWpds2}. \\


\subsubsection{4. Backwards Flow Stacking Returns}

\noindent The conversion is performed by:



\begin{mathpar}
{\inferrule*[left=\textsc{States}]
  { }
  {p \in P}
}
\and 
{\inferrule*
  { (q_c,\sigma,q_e) \in \delta_c }
  { p_{q_e} \in P }
}
\and
{\inferrule*
  { q \in Q }
  { q \in \Gamma }
}
\and 
{\inferrule*%%[left=\textsc{Internal}]
  { (q,\sigma,q') \in \delta_i }
  { \langle  p,q' \rangle \stackrel{w_1}{\hookrightarrow} \langle p,q \rangle \in \Delta_1 }
}
\and
{\inferrule*%%[left=\textsc{Call}]
  { (q_c,\sigma, q_e) \in \delta_c }
  { \langle  p,q_e \rangle \stackrel{w_0}{\hookrightarrow} \langle p_{q_e},\epsilon \rangle \in \Delta_0 \\
    \langle  p_{q_e},q_c \rangle \stackrel{w_3}{\hookrightarrow} \langle p,q_c \rangle \in \Delta_1  }
}
\and 
{\inferrule*%%[left=\textsc{Return}]
  { (q_x,q_c,\sigma,q_r) \in \delta_r }
  { \langle p,q_r \rangle \stackrel{w_2}{\hookrightarrow} \langle p,q_x \hspace{.1cm} q_c  \rangle \in \Delta_2 }
}
\end{mathpar}
\begin{align*}
\text{where }
w_0 &= \mathtt{wg.getOne}() \\
w_1 &= \begin{cases}
           \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
           \mathtt{wg.getWildWeight}(q,CI_q,q',CI_{q'}), & \text{if } \sigma = \text{\wild} \\
           \mathtt{wg.getWeight}(q,CI_q,\sigma, \mathtt{INTRA},q',CI_{q'}), & \text{otherwise}
       \end{cases} \\
w_2 &= \begin{cases}
          \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
          \mathtt{wg.getWildWeight}(q_x,CI_{q_x},q_r,CI_{q_r}), & \text{if } \sigma = \text{\wild} \\
          \mathtt{wg.getWeight}(q_x,CI_{q_x},\sigma, \mathtt{EXIT\_TO\_RET},q_r,CI_{q_r}), & \text{otherwise}
      \end{cases} \\
w_3 &= \begin{cases}
           \mathtt{wg.getOne}(), & \text{if } \sigma = \epsilon \\
           \mathtt{wg.getWildWeight}(q_c,CI_{q_c},q_e,CI_{q_e}), & \text{if } \sigma = \text{\wild} \\
           \mathtt{wg.getWeight}(q_c,CI_{q_c},\sigma, \mathtt{CALL\_TO\_ENTRY},q_e,CI_{q_e}), & \text{otherwise}
      \end{cases} 
\end{align*}



\begin{enumerate}

\item For each $(q,\sigma,q')$ $\in \delta_i$ in the NWA, adding $\langle
  p,q' \rangle \hookrightarrow \langle p,q \rangle$ to $\Delta_1$ of the WPDS
  (with weight
  \texttt{wg.getWeight($q$,$CI_q$,$\sigma$,INTRA,$q'$,$CI_{q'}$}) or
  \texttt{wg.getWildWeight($q$,$CI_q$,$q'$,$CI_{q'}$)}, depending on $\sigma$
  ).

\item For each $(q_c,\sigma, q_e)$ $\in \delta_c$ in the NWA, adding $\langle
  p,q_e \rangle \hookrightarrow \langle p_{q_e},\epsilon \rangle$ to
  $\Delta_0$ of the WPDS (with weight \texttt{wg.getOne()} ) and $\langle
  p_{q_e},q_c \rangle \hookrightarrow \langle p,q_c \rangle$ to $\Delta_1$ of
  the WPDS (with weight
  \texttt{wg.getWeight($q_c$,$CI_{q_c}$,$\sigma$,CALL\_TO\_ENTRY,$q_e$,$CI_{q_e}$)}
  or \texttt{wg.getWildWeight($q_c$,$CI_{q_c}$,$q_e$,$CI_{q_e}$)}, depending
  on $\sigma$).

\item For each $(q_x,q_c,\sigma,q_r)$ $\in \delta_r$ in the NWA, adding
  $\langle p,q_r \rangle \hookrightarrow \langle p,q_x \hspace{.1cm} q_c
  \rangle$ to $\Delta_2$ of the WPDS (with weight
  \texttt{wg.getWeight($q_x$,$CI_{q_x}$,$\sigma$,EXIT\_TO\_RET,$q_r$,$CI_{q_r}$)}
  or \texttt{wg.getWildWeight($q_x$,$CI_{q_x}$,$q_r$,$CI_{q_r}$)}, depending
  on $\sigma$).
\end{enumerate}

\noindent Consider, as an example, converting the NWA in
\figref{NwaToWpds3} into a backwards flow WPDS.  The WPDS resulting from
converting the WPDS shown in \figref{NwaToWpds1} into a backwards flow
WPDS is shown in \figref{NwaToWpds3}. \\



