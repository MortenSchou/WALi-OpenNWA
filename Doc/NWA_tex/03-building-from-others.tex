\section{Building NWAs from other NWAs (or ``the \texttt{wali::nwa::construct} namespace'')}
\label{Se:Building NWAs}

NWAs do not need to be built state-by-state and transition-by-transition;
they can also be built by performing language-theoretic operations upon
other NWAs. The supported operations are union, intersection, concatenation,
reversal, Kleene star, complement, and determinization.

The library supports two interfaces to each of these operations. In one, the
operation allocates an NWA with \texttt{new}, performs the construction, and
returns a \texttt{NWARefPtr} to the result.  In the other, the operation takes
a reference to an NWA, clears it, and constructs the result in-place. The
first form is usually more convenient to use, and creates a mini language for
set expressions; the second form makes it possible to store the result of an
operation in a subclass of \texttt{NWA}.

Each of these functions is in the namespace \texttt{wali::nwa::construct}:

\begin{functionlist}

  \functionitem[\texttt{NWARefPtr unionNWA( NWA const \& a, NWA const \& b )}]
  \functionitem[\texttt{void unionNWA( NWA \& out, NWA const \& a, NWA const \& b )}]
    Computes the union of the NWAs \texttt{a} and \texttt{b},
    either returning the result or storing it in \texttt{out}.
    See Section
    \ref{Se:Union}.

  \functionitem[\texttt{NWARefPtr intersect( NWA const \& a, NWA const \& b )}]
  \functionitem[\texttt{void intersect( NWA \& out, NWA const \& a, NWA const \& b )}]
    Computes the intersection of the NWAs \texttt{a} and \texttt{b},
    either returning the result or storing it in \texttt{out}.
    See Section \ref{Se:Intersection}.

  \functionitem[\texttt{NWARefPtr concat( NWA const \& left, NWA const \& right )}]
  \functionitem[\texttt{void concat( NWA \& out, NWA const \& left, NWA const \& right )}]
    Computes the concatenation of the NWAs \texttt{left} and
    \texttt{right}, either returning the result or storing it in
    \texttt{out}.
    See Section \ref{Se:Concatenation}.

  \functionitem[\texttt{NWARefPtr star( NWA const \& orig )}]
  \functionitem[\texttt{void star( NWA \& out, NWA const \& orig )}]
    Computes the Kleene-Star of the NWA \texttt{orig}, either
    returning the result or storing it in \texttt{out}. See Section
    \ref{Se:Star}.

  \functionitem[\texttt{NWARefPtr reverse( NWA const \& orig )}]
  \functionitem[\texttt{void reverse( NWA \& out, NWA const \& orig )}]
    Computes the NWA that accepts the reverse of each nested word
    accepted by the NWA \texttt{orig}, either returning the result or
    storing it in \texttt{out}. See Section \ref{Se:Reverse}.

  \functionitem[\texttt{NWARefPtr determinize( NWA const \& orig )}]
  \functionitem[\texttt{NWARefPtr determinize( NWA \& out, NWA const \& orig )}]
    Computes a determinization of \texttt{orig}, either returning the
    result or storing it in \texttt{out}.
    See Section \ref{Se:Determinize}.

  \functionitem[\texttt{NWARefPtr complement( NWA const \& orig )}]
  \functionitem[\texttt{void complement( NWA \& out, NWA const \& orig )}]
    Computes the complement of the determinization of \texttt{orig},
    either returning the result or storing it in \texttt{out}.
    See Section
    \ref{Se:Complement}.
\end{functionlist}

As mentioned above, these functions create a small language of set
expressions. For instance, to compute an automaton \texttt{M} whose language
is $\texttt{A} \cup (\texttt{B} \cap \texttt{C})*$ (where \texttt{A},
\texttt{B}, and \texttt{C} are \texttt{NWARefPtr}s), one can write
\begin{center}
  \texttt{NWARefPtr M = unionNWA(*A, *star(*intersect(*B, *C)))}
\end{center}


\subsection{Union}
\label{Se:Union}
The union of two NWAs is constructed by taking the union of each of the
components of the NWAs. (In
particular, it does \textsl{not} do a cross-product construction, and will
\textsl{always} produce a nondeterministic automaton as a result as long as
both machines have at least one initial state.)

Formally, given $N$ and $M$ such that
\begin{itemize}
 \item $N = (Q_N, \Sigma_N, Q_{0,N}, \delta_N, F_N)$
 \item $M = (Q_M, \Sigma_M, Q_{0,M}, \delta_M, F_M)$
\end{itemize}
then the union is computed as follows:
\begin{itemize}
 \item $N \cup M = (Q_N \cup Q_M, \Sigma_N \cup \Sigma_M, Q_{0,N} \cup
   Q_{0,M}, \delta_N \cup \delta_M, F_N \cup F_M)$
\end{itemize}

As an example, \figref{Union2} illustrates the union of \figref{Example1} and
\figref{Union1}.


\begin{figure}[htb]
  \centering
    \nwaimage[width=12cm]{Figures/figure-1}
  \caption{An example NWA.}
  \label{Fi:Example1}
\end{figure}


\begin{figure}[htbp]
  \centering
    \nwaimage[width=8cm]{Figures/union-other}
  \caption{Simple NWA to union with the NWA in Figure \ref{Fi:Example1}.}
  \label{Fi:Union1}
\end{figure}

\begin{figure}[htbp]
  \centering
    \nwaimage[width=12cm]{Figures/union-result}
  \caption{The NWA resulting from the union of the NWA in Figure
    \ref{Fi:Example1} and the NWA in Figure \ref{Fi:Union1}.}
  \label{Fi:Union2}
\end{figure}

The state sets of the NWAs must not overlap,
i.e., $Q_1 \cap Q_2 = \emptyset$. \textsl{Client code should not rely on
  this condition being checked} or any particular behavior occurring if it
does not hold. (Currently the condition is checked in an assertion.)

Client information is copied directly from the original NWAs using
\texttt{ClientInfo::clone()}.


\subsection{Intersection}
\label{Se:Intersection}

The intersection of two NWAs is computed in the standard cross-product
fashion, using a worklist algorithm to only compute those states that
are reachable.

The algorithm traverses the original NWAs starting at
the initial states and incrementally adds transitions for each pair of
``intersectable'' transitions that are encountered. By default, transitions
are intersectable when the transitions are the same kind (internal, call,
or return) and the symbols on the edge are identical (or at least one is wild
or epsilon).

\figref{Intersect1} shows the intersection of \figref{Example1} and
\figref{Intersect1}.
 
\begin{figure}[htbp]
  \centering
    \nwaimage[width=10cm]{Figures/intersection-simple-other}
  \caption{Simple NWA to intersect with the NWA in Figure \ref{Fi:Example1}.}
  \label{Fi:Intersect1}
\end{figure}

\begin{figure}[htbp]
  \centering
    \nwaimage[width=8cm]{Figures/intersection-simple-result}
  \caption{The NWA resulting from the intersection of the NWA in Figure
    \ref{Fi:Example1} and the NWA in Figure \ref{Fi:Intersect1}.}
  \label{Fi:Intersect2}
\end{figure}

It is possible to customize what symbols are considered equivalent by
overriding the \texttt{transitionIntersect} function in a subclass of
\texttt{NWA}. In addition, it is possible to impose additional constraints on
what states can be combined by overriding \texttt{stateIntersect}. Both
functions also produce the result of the intersection:
\texttt{transitionIntersect} produces the symbol that will be used on the
resulting edge, and \texttt{stateIntersect} produces the state that will be
used as the target.

The default behavior of
\texttt{transitionIntersect} is that two transitions are intersectable if
neither symbol is epsilon and either the symbols are the same or at least one of
the symbols is a wild. (Epsilon transitions are dealt with in
\texttt{intersect()} itself. If you override \texttt{transitionIntersect}, it
should return \texttt{false} if either input is epsilon.)

The default behavior of \texttt{stateIntersect} is that any two
states can be combined, the resulting state is labeled with a
\texttt{Key} that is uniquely generated from the pair of the \texttt{Keys} of
the two states under consideration, and the client information associated
with the resulting state is \texttt{null}.


Client information is generated by the helper method \texttt{stateIntersect},
but can be altered through the use of the helper methods
\texttt{intersectClientInfoInternal}, \texttt{intersectClientInfoCall}, and
\texttt{intersect\-Client\-InfoReturn}, which are invoked by
\texttt{intersect()} as transitions of the three different kinds involving the
associated state are added.  The default behavior of these three functions is
to perform no changes to the \texttt{ClientInfo}.  These methods can be
overridden in subclasses to specify alternative behaviors.

\goodbreak
\noindent The following operations are methods of class NWA and are intended
to be overridden to customize behavior:

\begin{functionlist}

  \functionitem[\texttt{bool stateIntersect( NWA const \& first, Key state1,\\ 
                   \hspace*{3.25cm} NWA const \& second, Key state2,\\
                   \hspace*{3.25cm} Key\& resSt, ref\_ptr<ClientInfo>\& resCI )}]
    \nopagebreak

    Determines whether the given states can be combined and,
    if so, creates the combined state. If the two states are incompatable,
    returns \texttt{false}. If the two states are compatable, it computes the
    key of the combined state (storing it in \texttt{resSt} and the client
    information (storing it in \texttt{resCI}), then returns \texttt{true}.

  \functionitem[\texttt{bool transitionIntersect( NWA const \& first, Key
    sym1,\\ \hspace*{3.25cm} NWA const \& second, Key
    sym2,\\ \hspace*{3.25cm} Key\& resSym )}] \nopagebreak

    Determines whether the given symbols are considered to be equivalent for
    the purposes of intersection. If so, it computes the symbol that should
    be associated with the combined transition (storing it in
    \texttt{resSym}) and returns true. If not, returns false.

  \functionitem[\texttt{void intersectClientInfoInternal( \\ \hspace*{3.25cm}
    NWA const \& first, Key src1, Key tgt1,\\ \hspace*{3.25cm} NWA const \&
    second, Key src2, Key tgt2,\\ \hspace*{3.25cm} Key resSym, Key resSt )}]
    \nopagebreak
  \functionitem[\texttt{void intersectClientInfoCall( \\ \hspace*{3.25cm}
    NWA const \& first ,Key call1, Key entry1,\\ \hspace*{3.25cm}
    NWA const \& second, Key call2, Key entry2,\\ \hspace*{3.25cm} Key
    resSym, Key resSt )}] \nopagebreak
  \functionitem[\texttt{void intersectClientInfoReturn( \\ \hspace*{1.75cm}
    NWA const \& first, Key exit1, Key call1, Key ret1,\\ \hspace*{1.75cm}
    NWA const \& second, Key exit2, Key call2, Key ret2,\\ \hspace*{1.75cm}
    Key resSym, Key resSt )}]

    Alters the client information assoicated with \texttt{resSt} given the
    endpoints of the transition just added (as well as access to the client
    information associated with each state).

\end{functionlist}


Consider the slightly more complex example of computing the intersection of
the NWAs shown in Figure \ref{Fi:Intersect3}.  The resulting NWA is shown in
Figure \ref{Fi:Intersect4}.

\begin{figure}[p]
  \centering
    \nwaimage[width=12cm]{Figures/intersection-complex-first}
    \nwaimage[width=12cm]{Figures/intersection-complex-result}
  \caption{Complex NWAs to intersect.}
  \label{Fi:Intersect3}
\end{figure}

\begin{figure}[p]
  \centering
    \nwaimage[width=12cm]{Figures/intersection-complex-result}
  \caption{The NWA resulting from the intersection of the NWAs in Figure \ref{Fi:Intersect3}.}
  \label{Fi:Intersect4}
\end{figure}



\subsection{Concatenation}
\label{Se:Concatenation}

The concatenation of two NWAs is constructed by taking the union of all
states and transitions of the two automata then adding
internal epsilon transitions from each final state of the first NWA to each
initial state of the second NWA.  In the resulting NWA, the initial states
are the initial states from the first NWA, and the final states are the final
states of the second NWA. % If the original NWAs are $(Q_1, \Sigma_1,
%{Q_0}_1, \delta_1, {Q_f}_1)$ and $(Q_2, \Sigma_2, {Q_0}_2, \delta_2,
%{Q_f}_2)$, then the resulting NWA is $(Q, \Sigma, Q_0, \delta, Q_f)$ where $Q
%= Q_1 \cup Q_2$, $\Sigma = \Sigma_1 \cup \Sigma_2$, $Q_0 = {Q_0}_1$, $\delta
%= \delta_1 \cup \delta_2 \cup \delta_\epsilon$ (where $\delta_\epsilon =
%\{(q,\epsilon,q') | q \in {Q_f}_1, q' \in {Q_0}_2\}$, and $Q_f = {Q_f}_2$ .
%The NWA resulting from the concatenation of the NWA in Figure
%\ref{Fi:Example1} and the NWA shown in Figure \ref{Fi:Concat1} is shown in
%Figure \ref{Fi:Concat2}.

%The state sets of the NWAs must not overlap,
%i.e., $Q_1 \cap Q_2 = \emptyset$. \textsl{Client code should not rely on
%  this condition being checked} or any particular behavior occurring if it
%does not hold. (Currently the condition is checked in an assertion.)

Client information is copied directly from the original NWAs using
\texttt{ClientInfo::clone()}.

\figref{Concat2} shows the result of concatenating \figref{Example1} and
\figref{Concat1}.



\begin{figure}[p]
  \centering
    \nwaimage[width=10cm]{Figures/concat-other}
  \caption{Simple NWA to concatenate onto the NWA in Figure \ref{Fi:Example1}.}
  \label{Fi:Concat1}
\end{figure}

\begin{figure}[p]
  \centering
    \nwaimage[width=12cm]{Figures/concat-result}
  \caption{The NWA resulting from the concatenation of the NWA in Figure
    \ref{Fi:Example1} with the NWA in Figure \ref{Fi:Concat1}.}
  \label{Fi:Concat2}
\end{figure}


\subsection{Kleene-Star}
\label{Se:Star}

\begin{changebar}
If the original NWA is $(Q, \Sigma, Q_0, \delta, Q_f)$,
then the result of performing Kleene-Star on that NWA is $(Q', \Sigma,
Q_0', \delta', Q_0')$ where $\delta' =
\{\delta_i',\delta_c',\delta_r'\}$ using the following rules:

\begin{mathpar}
{\inferrule*[left=\textsc{States}]
         {q \in Q}
  { q \in Q' \\ q' \in Q'}
} \\
\and
{\inferrule*[left=\textsc{Internal}]
             {(q,a,p) \in \delta_i }
  { (q,a,p) \in  \delta_i' \\ (q',a,p') \in \delta_i'}
}
\and
{\inferrule*
  {(q,a,p) \in \delta_i \\ p \in Q_f \\ r \in  Q_0}
  {(q,a,r') \in \delta_i'\\ (q',a,r') \in \delta_i' }
}
\and
{\inferrule*[left=\textsc{Call}]
           { (q,a,p) \in \delta_c  }
  { (q,a,p) \in  \delta_c' \\ (q',a,p) \in \delta_c'   }
}
\and
{\inferrule*
    { (q,a,p) \in \delta_c \\ p \in Q_f \\ r \in Q_0 }
  { (q,a,r') \in \delta_c'\\ (q',a,r') \in \delta_c' }
}
\and
{\inferrule*[left=\textsc{Return}]
              { (q,r,a,p) \in \delta_r }
  {(q,r,a,p) \in  \delta_r' \\ (q,r',a,p') \in \delta_r' }
}
\and
{\inferrule*
  { (q,a,p) \in \delta_c \\ p \in Q_f \\  r \in Q_0}
  {(q,r,a,s') \in \delta_r' \\ (q,r',a,s') \in \delta_r'  }
}
\end{mathpar}

\end{changebar}

\noindent The NWA resulting from performing Kleene-Star on the NWA shown in
\figref{Star1} is shown in \figref{Star2}.  Note: The primed
states, $q'$ are constructed using \texttt{getKey($q$,getKey("prime"))} for
$q \in Q$.

\begin{figure}[p]
  \centering
    \nwaimage[width=10cm]{Figures/star-simple}
  \caption{An NWA on which to perform Kleene-Star.}
  \label{Fi:Star1}
\end{figure}

\begin{figure}[p]
  \centering
    \nwaimage[width=12cm]{Figures/star-simple-result}
  \caption{The NWA resulting from performing Kleene-Star on the NWA in Figure \ref{Fi:Star1}.}
  \label{Fi:Star2}
\end{figure}

\goodbreak Client information is copied directly from the original NWA (using
\texttt{ClientInfo::clone()}) such that for each $q \in Q$, $q$
and $q'$ have the same client information.

%Consider the slightly more complex example of computing the Kleene-Star of the NWA shown in Figure \ref{Fi:Star3}.  The resulting NWA is shown in Figure \ref{Fi:Star4}.

%\begin{figure}[htbp]
%  \centering
%    \includegraphics[angle=270,width=10cm]{Figures/Figure13.pdf}
%  \caption{Complex NWA on which to perform Kleene-Star.}
%  \label{Fi:Star3}
%\end{figure}

%\begin{figure}[htbp]
%  \centering
%    \includegraphics[angle=270,width=12cm]{Figures/Figure14.pdf}
%  \caption{The NWA resulting from performing Kleene-Star on the NWA in Figure \ref{Fi:Star3}.}
%  \label{Fi:Star4}
%\end{figure}

\subsection{Reverse}
\label{Se:Reverse}

\begin{changebar}

If the original NWA is $(Q, \Sigma, Q_0, \delta, Q_f)$, then the result of
reversing that NWA is $(Q, \Sigma, Q_0, \delta_{rev}, Q_f)$ obtained using
the following rules:

\begin{mathpar}
{\inferrule*[left=\textsc{Internal}]
     { (q,\sigma,q') \in \delta_i  }
  { (q',\sigma,q)  \in {\delta_{rev}}_i }
} 
\and
{\inferrule*[left=\textsc{Call}]
       { (q_c,\sigma,q_e) \in \delta_c }
  { (q_e,\sigma,q_c) \in {\delta_{rev}}_c }
}
\and
{\inferrule*[left=\textsc{Return}]
  { (q_x,q_c,\sigma,q_r) \in \delta_r  \\ (q_c,\sigma,q_e) \in  \delta_c }
  { (q_r,q_e,\sigma,q_x) \in {\delta_{rev}}_r }
}
\end{mathpar}
\end{changebar}

\noindent The NWA resulting from performing reverse on the NWA shown in
Figure \ref{Fi:Example1} is shown in Figure \ref{Fi:Reverse1}.
 
\begin{figure}[p]
  \centering
    \nwaimage[width=12cm]{Figures/reverse-of-figure-1}
  \caption{The NWA resulting from performing reverse on the NWA in Figure \ref{Fi:Example1}.}
  \label{Fi:Reverse1}
\end{figure}

Client
information is copied directly from the original NWA using
\texttt{ClientInfo::clone()}.

\subsection{Determinize}
\label{Se:Determinize}

\begin{definition}
An NWA, $(Q,\Sigma,Q_0,\delta,Q_f)$, is \textbf{deterministic} iff 

\begin{enumerate} 

\item $|Q_0| = 1$, 

\item For all $q \in Q$: 
  \begin{itemize}
    \item if $(q,*,q') \in \delta_i$ then $|\{q'|(q,\sigma,q') \in
      \delta_i\}| = 0$; otherwise, for all $\sigma \in \Sigma - \{*\},
      |\{q'|(q,\sigma,q') \in \delta_i\}| \leq 1$,

    \item if $(q,*,q') \in \delta_c$ then $ |\{q'|(q,\sigma,q') \in
      \delta_c\}| = 0$; otherwise, for all $\sigma \in \Sigma - \{*\},
      |\{q'|(q,\sigma,q') \in \delta_c\}| \leq 1$, and

    \item for all $q' \in Q$, if $(q,q',*,q'') \in \delta_r$ then
      $|\{q''|(q,q',\sigma,q'') \in \delta_r\}| = 0$; otherwise, for all
      $\sigma \in \Sigma - \{*\}, |\{q''|(q,q',\sigma,q'') \in \delta_r\}|
      \leq 1$, and
  \end{itemize}
\item For all $(q,\sigma,q') \in \delta_i, \sigma \neq \epsilon$,

 for all $(q,\sigma,q') \in \delta_c, \sigma \neq \epsilon$,  and 

 for all $(q,q',\sigma,q'') \in \delta_r, \sigma \neq \epsilon$.\\

\end{enumerate}

If an NWA is not deterministic, then it is \textbf{non-deterministic}.
\end{definition}

Determinizing an NWA operates like a
generalization of the classical subset construction.  Instead of the states
in the determinized NWA being subsets of the original NWA, states of the
determinized NWA are sets of state pairs (i.e., binary relations on states)
\cite{JACM:AM2009}.  To support determinization, the library provides a
typedef of \texttt{std::set$<$pair$<$State, State$>>$} as 
\texttt{NWA::BinaryRelation}. See also \texttt{wali/nwa/RelationOps.hpp}.

%There is very experimental support for using the BuDDY


The result of determinizing the automaton in \figref{Det1} is shown in
\figref{Det2}.

\begin{figure}[p]
  \centering
    \nwaimage[width=12cm]{Figures/determinize}
  \caption{Simple nondeterministic NWA.}
  \label{Fi:Det1}
\end{figure}


\begin{figure}[p]
  \centering
    \nwaimage[width=16cm]{Figures/determinize-result}
    \caption{The NWA resulting from determinizing the NWA in Figure
      \ref{Fi:Det1}. As mentioned in the text, states in the determinized
      NWA are relations on the states in the original NWA. For example, state
      1 above corresponds to the relation $\{$(Start,Stuck), (Call,Stuck),
      (Entry1,Stuck), (Entry2,Exit2), (State1,Stuck), (State2,Stuck),
      (Exit1,Stuck), (Exit2,Stuck), (Return,Stuck), (Fishish,Stuck),
      (Stuck,Stuck)$\}$.}
 
  \label{Fi:Det2}
\end{figure}


Client information is generated through the use of the helper method
\texttt{mergeClientInfo}, but can be altered through the use of the helper
methods \texttt{mergeClientInfoInternal}, \texttt{mergeClientInfoCall}, and
\texttt{mergeClientInfoReturn}, which are invoked by \texttt{determinize} as
transitions of the three kinds involving the associated state are added.  The
default behavior of \texttt{mergeClientInfo} is that the \texttt{ClientInfo}
associated with the resulting state is \texttt{null}.  The default behavior
of \texttt{mergeClientInfoInternal}, \texttt{mergeClientInfoCall}, and
\texttt{mergeClientInfoReturn} is to make no changes to the the
\texttt{ClientInfo}.  These methods can be overridden to specify alternative
behaviors.  As determinization is performed, \texttt{mergeClientInfo} is
called each time a new state is created.  Then, as each transition is added,
\texttt{mergeClientInfoInternal}, \texttt{mergeClientInfoCall}, or
\texttt{mergeClientInfoReturn} is called (depending on the type of transition
being added) to update the \texttt{ClientInfo} associated with the target
state of the transition being added.

The following functions can be overridden in a subclass of \texttt{NWA} to
customize the behavior of determinization.

\begin{functionlist}

  \functionitem[\texttt{void mergeClientInfo( NWA const \& first,\\ \hspace*{3.25cm}
    BinaryRelation const\& binRel,\\ \hspace*{3.25cm} St resSt,
    ref\_ptr<ClientInfo>\& resCI )}] \nopagebreak

    Computes the client information that should be associated with the given state.

  \functionitem[\texttt{void mergeClientInfoInternal( NWA const \& first,\nopagebreak
    \\ \hspace*{3.25cm} BinaryRelation const\& binRelSource,\nopagebreak
    \\ \hspace*{3.25cm} BinaryRelation const\& binRelTarget, \nopagebreak
    \\ \hspace*{3.25cm} Key sourceSt, Key resSym, Key resSt, \nopagebreak
    \\ \hspace*{3.25cm} ref\_ptr<ClientInfo>\& resCI )}] \nopagebreak
  \functionitem[\texttt{void mergeClientInfoCall( NWA const \&
    first,\\ \hspace*{3.25cm} BinaryRelation const\&
    binRelCall,\\ \hspace*{3.25cm} BinaryRelation const\&
    binRelEntry,\\ \hspace*{3.25cm} Key callSt, Key resSym, Key
    resSt,\\ \hspace*{3.25cm} ref\_ptr<ClientInfo>\& resCI )}] \nopagebreak
  \functionitem[\texttt{void mergeClientInfoReturn( NWA const \&
    first,\\ \hspace*{3.25cm} BinaryRelation const\&
    binRelExit,\\ \hspace*{3.25cm} BinaryRelation const\&
    binRelCall,\\ \hspace*{3.25cm} BinaryRelation const\&
    binRelReturn,\\ \hspace*{3.25cm} Key exitSt, Key callSt, Key
    resSym,\\ \hspace*{3.25cm} Key resSt, ref\_ptr<ClientInfo>\& resCI )}]
    \nopagebreak

    Alters the client information associated with \texttt{resSt} given
    information about the transition being added to the determinized
    automaton.

\end{functionlist}

%Consider the slightly more complex determinization of the NWA shown in Figure \ref{Fi:Det3}.  The resulting NWA is shown in Figure \ref{Fi:Det4}.

%\begin{figure}[htbp]
%  \centering
%    \includegraphics[angle=270,width=12cm]{Figures/Figure18.pdf}
%  \caption{Complex nondeterministic NWA.}
%  \label{Fi:Det3}
%\end{figure}

%\begin{figure}[htbp]
%  \centering
%    \includegraphics[angle=270,width=12cm]{Figures/Figure19.pdf}
%  \caption{The NWA resulting from determinizing the NWA in Figure \ref{Fi:Det3}.}
%  \label{Fi:Det4}
%\end{figure}

\subsection{Complement}
\label{Se:Complement}

The complement is performed by first determinizing the NWA and then
complementing the final-state set of the determinized NWA.  The NWA resulting
from performing the complement of the NWA shown in Figure \ref{Fi:Det1} is
shown in Figure \ref{Fi:Comp1}.

\begin{figure}[p]
  \centering
    \nwaimage[width=12cm]{Figures/complement-of-determinize}
  \caption{The complement of the NWA in Figure \ref{Fi:Det1} (the
    determinization of which is shown in Figure \ref{Fi:Det2}).}
  \label{Fi:Comp1}
\end{figure}

Client information is copied directly
from the determinization of the original NWA using \texttt{ClientInfo::clone()}.


