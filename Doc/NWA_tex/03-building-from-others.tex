\section{Building NWAs from other NWAs}
\label{Se:Building NWAs}

NWAs do not need to be built state-by-state and transition-by-transition, they can also be built by performing language-theoretic operations over component NWAs. These operations include: union, intersection, concatenation, reversal, Kleene-star, complement, and determinize. The library supports two interfaces to the Boolean operations.  In one, each operation returns a \texttt{ref\_ptr<NWA>} to a freshly-built NWA.  In the other, each operation transforms the NWA on which it was called. \\

\noindent The following operations are methods of class NWA:

\begin{description}

  \item\texttt{static ref\_ptr<NWA> unionNWA( ref\_ptr<NWA> first, \\ \hspace*{3.25cm} ref\_ptr<NWA> second, Key stuck )} \nopagebreak

    The result is the union of the NWAs \texttt{first} and \texttt{second}.
    The stuck state of the resulting NWA is \texttt{stuck}.  See Section
    \ref{Se:Union}.

  \item\texttt{static ref\_ptr<NWA> intersect( ref\_ptr<NWA> first, \\ \hspace*{3.25cm} ref\_ptr<NWA> second, Key stuck )} \nopagebreak

    The result is the intersection of the NWAs \texttt{first} and
    \texttt{second}.  The stuck state of the resulting NWA is \texttt{stuck}.
    See Section \ref{Se:Intersection}.

  \item\texttt{static ref\_ptr<NWA> concat( ref\_ptr<NWA> first, \\ \hspace*{3.25cm} ref\_ptr<NWA> second, Key stuck )} \nopagebreak

    The result is the concatenation of the NWAs \texttt{first} and
    \texttt{second}.  The stuck state of the resulting NWA is \texttt{stuck}.
    See Section \ref{Se:Concatenation}.

  \item\texttt{static ref\_ptr<NWA> star( ref\_ptr<NWA> first, Key stuck )} \nopagebreak

    The result is the Kleene-Star of the NWA \texttt{first}.  The stuck state
    of the resulting NWA is \texttt{stuck}.  See Section \ref{Se:Star}.

  \item\texttt{static ref\_ptr<NWA> reverse( ref\_ptr<NWA> first, Key stuck )} \nopagebreak

    The result is the NWA which accepts the reverse of each nested word
    accepted by the NWA \texttt{first}.  The stuck state of the resulting NWA
    is \texttt{stuck}.  See Section \ref{Se:Reverse}.

  \item\texttt{static ref\_ptr<NWA> determinize( ref\_ptr<NWA> nondet, Key stuck )} \nopagebreak

    The result is the deterministic NWA that is equivalent to the NWA
    \texttt{nondet}.  The stuck state of the resulting NWA is \texttt{stuck}.
    See Section \ref{Se:Determinize}.

  \item\texttt{static ref\_ptr<NWA> complement( ref\_ptr<NWA> first, Key stuck )} \nopagebreak

    The result is the NWA which is the complement of the NWA \texttt{first}.
    The stuck state of the resulting NWA is \texttt{stuck}.  See Section
    \ref{Se:Complement}.

  \item\texttt{void unionNWA( ref\_ptr<NWA> first, ref\_ptr<NWA> second )} \nopagebreak

    This operation is an instance method; the NWA referred to by
    \texttt{this} is transformed into the NWA resulting from the union of the
    NWAs \texttt{first} and \texttt{second}.  See Section \ref{Se:Union}.
    This method should not be called on an NWA of type 2, otherwise there is
    an assertion violation.  Typical sequence of operations: construct A with
    a stuck state; A.unionNWA(B,C);

 \item\texttt{void intersect( ref\_ptr<NWA> first, ref\_ptr<NWA> second )} \nopagebreak

    This operation is an instance method; the NWA referred to by
    \texttt{this} is transformed into the NWA resulting from the intersection
    of the NWAs \texttt{first} and \texttt{second}.  See Section
    \ref{Se:Intersection}.  This method should not be called on an NWA of
    type 2, otherwise there is an assertion violation.  Typical sequence of
    operations: construct A with a stuck state; A.intersect(B,C);

  \item\texttt{void concat( ref\_ptr<NWA> first, ref\_ptr<NWA> second )} \nopagebreak

    This operation is an instance method; the NWA referred to by
    \texttt{this} is transformed into the NWA resulting from concatenating
    the NWAs \texttt{first} and \texttt{second}.  See Section
    \ref{Se:Concatenation}.  This method should not be called on an NWA of
    type 2, otherwise there is an assertion violation.  Typical sequence of
    operations: construct A with a stuck state; A.concat(B,C);

  \item\texttt{void star( ref\_ptr<NWA> first )} \nopagebreak

    This operation is an instance method; the NWA referred to by
    \texttt{this} is transformed into the NWA resulting from performing the
    Kleene-Star operation on the NWA \texttt{first}.  See Section
    \ref{Se:Star}.  This method should not be called on an NWA of type 2,
    otherwise there is an assertion violation.  Typical sequence of
    operations: construct A with a stuck state; A.star(B);

  \item\texttt{void reverse( ref\_ptr<NWA> first )} \nopagebreak

    This operation is an instance method; the NWA referred to by
    \texttt{this} is transformed into the NWA which accepts the reverse of
    each nested word accepted by the NWA \texttt{first}.  See Section
    \ref{Se:Reverse}.  This method should not be called on an NWA of type 2,
    otherwise there is an assertion violation.  Typical sequence of
    operations: construct A with a stuck state; A.reverse(B);

  \item\texttt{void determinize( ref\_ptr<NWA> nondet )} \nopagebreak

    This operation is an instance method; the NWA referred to by
    \texttt{this} is transformed into the deterministic NWA that is
    equivalent to the NWA \texttt{nondet}.  See Section \ref{Se:Determinize}.
    This method should not be called on an NWA of type 2, otherwise there is
    an assertion violation.  Typical sequence of operations: construct A with
    a stuck state; A.determinize(B);

  \item\texttt{void complement( ref\_ptr<NWA> first )} \nopagebreak

    This operation is an instance method; the NWA referred to by
    \texttt{this} is transformed into the NWA resulting from complementing
    the NWA \texttt{first}.  See Section \ref{Se:Complement}.  This method
    should not be called on an NWA of type 2, otherwise there is an assertion
    violation.  Typical sequence of operations: construct Awith a stuck
    state; A.complement(B);

\end{description}

\subsection{Union}
\label{Se:Union}
Consider an example of computing the union of two NWAs, the NWA shown in
Figure \ref{Fig:Example1} and the NWA shown in Figure \ref{Fig:Union1}.  The
union is constructed by combining all functionality of both component NWAs.
If the component NWAs are $(Q_1, \Sigma_1, {Q_0}_1, \delta_1, {Q_f}_1)$ and
$(Q_2, \Sigma_2, {Q_0}_2, \delta_2, {Q_f}_2)$, then the resulting NWA is $(Q,
\Sigma, Q_0, \delta, Q_f)$ where $Q = Q_1 \cup Q_2$, $\Sigma = \Sigma_1 \cup
\Sigma_2$, $Q_0 = {Q_0}_1 \cup {Q_0}_2$, $\delta = \delta_1 \cup \delta_2$,
and $Q_f = {Q_f}_1 \cup {Q_f}_2$ .  The NWA resulting from the union of the
NWA shown in Figure \ref{Fig:Example1} and the NWA shown in Figure
\ref{Fig:Union1} is shown in Figure \ref{Fig:Union2}.  Note that the
resulting NWA is nondeterministic (because it has multiple initial states).

\begin{figure}[htbp]
  \centering
    \includegraphics[width=8cm]{Figures/Figure3}
  \caption{Simple NWA to union with the NWA in Figure \ref{Fig:Example1}.}
  \label{Fig:Union1}
\end{figure}

\begin{figure}[htbp]
  \centering
    \includegraphics[width=12cm]{Figures/Figure4}
  \caption{The NWA resulting from the union of the NWA in Figure \ref{Fig:Example1} and the NWA in Figure \ref{Fig:Union1}.}
  \label{Fig:Union2}
\end{figure}

The stuck state of the resulting NWA cannot appear in either of the component
NWAs, except as a stuck state.  Furthermore, to construct the union of two
NWAs, the state sets of the NWAs cannot overlap (except by the stuck state),
i.e. $Q_1 \cap Q_2 = \emptyset$ or $Q_1 \cap Q_2 = Stuck$, where $Stuck$ is
the stuck state of both NWAs. Client information is copied directly from the
component NWAs using the \texttt{ClientInfo} copy constructor.


\subsection{Intersection}
\label{Se:Intersection}

Consider an example of computing the intersection of two NWAs, the NWA shown
in Figure \ref{Fig:Example1} and the NWA shown in Figure
\ref{Fig:Intersect1}.  The intersection is constructed by traversing both
component NWAs starting at the initial states and incrementally adding
transitions for each pair of ``intersectable'' transitions that are
encountered.  Transitions are ``intersectable'' when \begin{inparaenum} \item
  the transitions are the same kind (internal, call, or return), \item the
  symbols of the transitions are identical,\footnote{Strictly speaking, the
    symbols do not have to be identical when the meta-symbols $\epsilon$ and
    $*$ are involved.  In addition, the client has the flexibility to change
    how identity of symbols is handled by overriding the method
    transitionIntersect.} and \item the states at each position in the
  transitions can be joined. \end{inparaenum} The resulting NWA is shown in
Figure \ref{Fig:Intersect2}.
 
\begin{figure}[htbp]
  \centering
    \includegraphics[width=10cm]{Figures/Figure5}
  \caption{Simple NWA to intersect with the NWA in Figure \ref{Fig:Example1}.}
  \label{Fig:Intersect1}
\end{figure}

\begin{figure}[htbp]
  \centering
    \includegraphics[width=8cm]{Figures/Figure6}
  \caption{The NWA resulting from the intersection of the NWA in Figure \ref{Fig:Example1} and the NWA in Figure \ref{Fig:Intersect1}.}
  \label{Fig:Intersect2}
\end{figure}

It is possible to customize what states and symbols are considered equivalent
by overriding the \texttt{stateIntersect} and \texttt{transitionIntersect}
methods.  The default behavior of \texttt{stateIntersect} is that any two
states can be intersected, the resulting state to add is labeled with a
\texttt{Key} that is uniquely generated from the pair of the \texttt{Keys} of
the two states under consideration, and the client information associated
with the resulting state is \texttt{null}.  The default behavior of
\texttt{transitionIntersect} is that two transitions are intersectable if the
symbols that label the transitions are not \texttt{epsilon}
(\texttt{$\epsilon$}) and either the symbols are the same or at least one of
the symbols is a \texttt{wild} (\texttt{*}).

Client information is generated by the helper method \texttt{stateIntersect},
but can be altered through the use of the helper methods
\texttt{intersectClientInfoInternal}, \texttt{intersectClientInfoCall}, and
\texttt{intersect\-Client\-InfoReturn}, which are invoked by
\texttt{intersect} as transitions of the three different kinds involving the
associated state are added.  The default behavior of these three functions is
to perform no changes to the \texttt{ClientInfo}.  These methods can be
overridden to specify alternative behaviors.

As intersection is performed, and the transitions of the component NWAs are
traversed, \texttt{transitionIntersect} is called to determine whether a
transition should be added to the resulting NWA.  If so,
\texttt{stateIntersect} is called to determine whether the target states of
the transitions in question can be joined.  Finally, if a transition is going
to be added to the resulting NWA, \texttt{intersectClientInfoInternal},
\texttt{intersectClientInfoCall}, or \texttt{intersectClientInfoReturn} is
called (as appropriate) to update the \texttt{ClientInfo} associated with the
target state of the transition being added. \\

\goodbreak
\noindent The following operations are methods of class NWA and are intended to be overridden to customize behavior:

\begin{description}

  \item\texttt{bool stateIntersect( ref\_ptr<NWA> first, Key state1,\\ \hspace*{3.25cm} ref\_ptr<NWA> second,Key state2,\\ \hspace*{3.25cm} Key\& resSt, ref\_ptr<ClientInfo>\& resCI )} \nopagebreak

    Determines whether the given states are considered to be equivalent for
    the purposes of intersection and, if so, creates the combined state,
    together with the client information that should be associated with the
    combined state and returns true.  Otherwise, returns false.
    
  \item\texttt{bool transitionIntersect( ref\_ptr<NWA> first, Key sym1,\\ \hspace*{3.25cm} ref\_ptr<NWA> second, Key sym2,\\ \hspace*{3.25cm} Key\& resSym )} \nopagebreak

    Determines whether the given symbols are considered to be equivalent for
    the purposes of intersection and, if so, computes the symbol which should
    be associated with the combined transition and returns true.  Otherwise,
    returns false.

  \item\texttt{void intersectClientInfoInternal( \\ \hspace*{3.25cm} ref\_ptr<NWA> first, Key src1, Key tgt1,\\ \hspace*{3.25cm} ref\_ptr<NWA> second, Key src2, Key tgt2,\\ \hspace*{3.25cm} Key resSym, Key resSt )} \nopagebreak

    Alters the client information associated with \texttt{resSt} given the
    sources and targets (as well as access to the client information
    associated with each state) of the two internal transitions that are
    being intersected.

  \item\texttt{void intersectClientInfoCall( \\ \hspace*{3.25cm} ref\_ptr<NWA> first ,Key call1, Key entry1,\\ \hspace*{3.25cm} ref\_ptr<NWA> second, Key call2, Key entry2,\\ \hspace*{3.25cm} Key resSym, Key resSt )} \nopagebreak

    Alters the client information associated with \texttt{resSt} given the
    call sites and entry points (as well as access to the client information
    associated with each state) of the two call transitions that are being
    intersected.

  \item\texttt{void intersectClientInfoReturn( \\ \hspace*{1.75cm} ref\_ptr<NWA> first, Key exit1, Key call1, Key ret1,\\ \hspace*{1.75cm} ref\_ptr<NWA> second, Key exit2, Key call2, Key ret2,\\ \hspace*{1.75cm} Key resSym, Key resSt )} \nopagebreak

    Alters the client information assoicated with \texttt{resSt} given the
    exit point, call site, and return site (as well as access to the client
    information associated with each state) of the two return transitions
    that are being intersected. \\

\end{description}


Consider the slightly more complex example of computing the intersection of the NWAs shown in Figure \ref{Fig:Intersect3}.  The resulting NWA is shown in Figure \ref{Fig:Intersect4}.  Note that a state is only made final if both of its component states were final in their respective NWAs (this can be seen in the state 'Call\_1,Dead\_End' where 'Dead\_End' was final, but 'Call\_1' was not).  

\begin{figure}[p]
  \centering
    \includegraphics[width=12cm]{Figures/Figure7a}
    \includegraphics[width=12cm]{Figures/Figure7b}
  \caption{Complex NWAs to intersect.}
  \label{Fig:Intersect3}
\end{figure}

\begin{figure}[p]
  \centering
    \includegraphics[width=12cm]{Figures/Figure8}
  \caption{The NWA resulting from the intersection of the NWAs in Figure \ref{Fig:Intersect3}.}
  \label{Fig:Intersect4}
\end{figure}

\subsection{Concatenation}
\label{Se:Concatenation}

Consider an example of computing the concatenation of two NWAs, the NWA shown
in Figure \ref{Fig:Example1} and the NWA shown in Figure \ref{Fig:Concat1}.
The concatenation is constructed by combining all states and transitions of
the first NWA (shown in Figure \ref{Fig:Example1}) and all states and
transitions of the second NWA (shown in Figure \ref{Fig:Concat1}) then adding
internal epsilon transitions from each final state of the first NWA to each
initial state of the second NWA.  In the resulting NWA, the initial states
are the initial states from the first NWA; the final states are the final
states of the second NWA.  If the component NWAs are $(Q_1, \Sigma_1,
{Q_0}_1, \delta_1, {Q_f}_1)$ and $(Q_2, \Sigma_2, {Q_0}_2, \delta_2,
{Q_f}_2)$, then the resulting NWA is $(Q, \Sigma, Q_0, \delta, Q_f)$ where $Q
= Q_1 \cup Q_2$, $\Sigma = \Sigma_1 \cup \Sigma_2$, $Q_0 = {Q_0}_1$, $\delta
= \delta_1 \cup \delta_2 \cup \delta_\epsilon$ (where $\delta_\epsilon =
\{(q,\epsilon,q') | q \in {Q_f}_1, q' \in {Q_0}_2\}$, and $Q_f = {Q_f}_2$ .
The NWA resulting from the concatenation of the NWA in Figure
\ref{Fig:Example1} and the NWA shown in Figure \ref{Fig:Concat1} is shown in
Figure \ref{Fig:Concat2}.

\begin{figure}[p]
  \centering
    \includegraphics[width=10cm]{Figures/Figure9}
  \caption{Simple NWA to concatenate onto the NWA in Figure \ref{Fig:Example1}.}
  \label{Fig:Concat1}
\end{figure}

\begin{figure}[p]
  \centering
    \includegraphics[width=12cm]{Figures/Figure10}
  \caption{The NWA resulting from the concatenation of the NWA in Figure
    \ref{Fig:Example1} with the NWA in Figure \ref{Fig:Concat1}.}
  \label{Fig:Concat2}
\end{figure}

The stuck state of the NWA on which the concat method is called cannot appear
in either of the component NWAs xcept as a stuck state.  Furthermore, in
order to construct the concatenation of two NWAs, the state sets of the NWAs
cannot overlap (except by the stuck state), i.e. $Q_1 \cap Q_2 = \emptyset$
or $Q_1 \cap Q_2 = Stuck$, where $Stuck$ is the stuck state of both
NWAs. Client information is copied directly from the component NWAs using the
\texttt{ClientInfo} copy constructor.

\subsection{Kleene-Star}
\label{Se:Star}

Consider an example of computing the Kleene-Star of the NWA shown in Figure
\ref{Fig:Star1}.  If the component NWA is $(Q, \Sigma, Q_0, \delta, Q_f)$,
then the result of performing Kleene-Star on that NWA is $(Q \cup Q', \Sigma,
Q_0', \delta', Q_0')$ where $Q' = \{q' | q \in Q\}$ and $\delta' =
\{\delta_i',\delta_c',\delta_r'\}$ such that

\begin{enumerate} 

\item For all $(q,a,p) \in \delta_i$, the result NWA has $(q,a,p) \in
  \delta_i'$ and $(q',a,p') \in \delta_i'$, and if $p \in Q_f$, then
  $(q,a,r') \in \delta_i'$ and $(q',a,r') \in \delta_i'$ for each $r \in
  Q_0$,

\item For all $(q,a,p) \in \delta_c$, the result NWA has $(q,a,p) \in
  \delta_c'$ and $(q',a,p) \in \delta_c'$, and if $p \in Q_f$, then $(q,a,r')
  \in \delta_c'$ and $(q',a,r') \in \delta_c'$ for each $r \in Q_0$,

\item For all $(q,r,a,p) \in \delta_r$, the result NWA has $(q,r,a,p) \in
  \delta_r'$ and $(q,r',a,p') \in \delta_r'$, and if $p \in Q_f$, then
  $(q,r,a,s') \in \delta_r'$ and $(q,r',a,s') \in \delta_r'$ for each $s \in
  Q_0$, and

\item For all $(q,r,a,p) \in \delta_r$ with $r \in Q_0$, the result NWA has
  $(q',s,a,p') \in \delta_r'$ for each $s \in Q \cup Q'$, and if $p \in Q_f$,
  then $(q',s,a,t') \in \delta_r'$ for each $s \in Q \cup Q'$ and $t \in Q_0$

\end{enumerate}  

\noindent The NWA resulting from performing Kleene-Star on the NWA shown in
Figure \ref{Fig:Star1} is shown in Figure \ref{Fig:Star2}.  Note: The primed
states, $q'$ are constructed using \texttt{getKey($q$,getKey(prime))} where
$q \in Q$ and \texttt{prime} is the string ``prime''.

\begin{figure}[p]
  \centering
    \includegraphics[width=10cm]{Figures/Figure11}
  \caption{An NWA on which to perform Kleene-Star.}
  \label{Fig:Star1}
\end{figure}

\begin{figure}[p]
  \centering
    \includegraphics[width=12cm]{Figures/Figure12}
  \caption{The NWA resulting from performing Kleene-Star on the NWA in Figure \ref{Fig:Star1}.}
  \label{Fig:Star2}
\end{figure}

\goodbreak The stuck state of the NWA on which the Kleene-Star method is
called cannot appear in the component NWA nor can it be the prime of any
state in the NWA (i.e., $stuck \not\in Q \cup Q'$) unless it is the stuck
state.  Client information is copied directly from the component NWA (using
the \texttt{ClientInfo} copy constructor) such that for each $q \in Q$, $q$
and $q'$ have the same client information.

%Consider the slightly more complex example of computing the Kleene-Star of the NWA shown in Figure \ref{Fig:Star3}.  The resulting NWA is shown in Figure \ref{Fig:Star4}.

%\begin{figure}[htbp]
%  \centering
%    \includegraphics[angle=270,width=10cm]{Figures/Figure13.pdf}
%  \caption{Complex NWA on which to perform Kleene-Star.}
%  \label{Fig:Star3}
%\end{figure}

%\begin{figure}[htbp]
%  \centering
%    \includegraphics[angle=270,width=12cm]{Figures/Figure14.pdf}
%  \caption{The NWA resulting from performing Kleene-Star on the NWA in Figure \ref{Fig:Star3}.}
%  \label{Fig:Star4}
%\end{figure}

\subsection{Reverse}
\label{Se:Reverse}

If the component NWA is $(Q, \Sigma, Q_0, \delta, Q_f)$, then the result of
reversing that NWA is $(Q, \Sigma, Q_0, \delta_{rev}, Q_f)$ such that

\begin{enumerate}

\item For all $(q,\sigma,q') \in \delta_i$, the result NWA has $(q',\sigma,q)
  \in {\delta_{rev}}_i$

\item For all $(q_c,\sigma,q_e) \in \delta_c$, the result NWA has
  $(q_e,\sigma,q_c) \in {\delta_{rev}}_c$

\item For all $(q_x,q_c,\sigma,q_r) \in \delta_r$ and $(q_c,\sigma,q_e) \in
  \delta_c$ (where the $q_c$s are the same), the result NWA has
  $(q_r,q_e,\sigma,q_x) \in {\delta_{rev}}_r$

\end{enumerate}

\noindent The NWA resulting from performing reverse on the NWA shown in
Figure \ref{Fig:Example1} is shown in Figure \ref{Fig:Reverse1}.
 
\begin{figure}[p]
  \centering
    \includegraphics[width=12cm]{Figures/Figure15}
  \caption{The NWA resulting from performing reverse on the NWA in Figure \ref{Fig:Example1}.}
  \label{Fig:Reverse1}
\end{figure}

The stuck state of the NWA on which the reverse method is called cannot be
any state in the component NWA (including the stuck state).  Client
information is copied directly from the component NWA using the
\texttt{ClientInfo} copy constructor.

\subsection{Determinize}
\label{Se:Determinize}

\begin{definition}
An NWA, $(Q,\Sigma,Q_0,\delta,Q_f)$, is \textbf{deterministic} iff 

\begin{enumerate} 

\item $|Q_0| = 1$, 

\item For all $q \in Q$: 
  \begin{itemize}
    \item if $(q,*,q') \in \delta_i$ then $|\{q'|(q,\sigma,q') \in
      \delta_i\}| = 0$; otherwise, for all $\sigma \in \Sigma - \{*\},
      |\{q'|(q,\sigma,q') \in \delta_i\}| \leq 1$,

    \item if $(q,*,q') \in \delta_c$ then $ |\{q'|(q,\sigma,q') \in
      \delta_c\}| = 0$; otherwise for all $\sigma \in \Sigma - \{*\},
      |\{q'|(q,\sigma,q') \in \delta_c\}| \leq 1$, and

    \item for all $q' \in Q$, if $(q,q',*,q'') \in \delta_r$ then
      $|\{q''|(q,q',\sigma,q'') \in \delta_r\}| = 0$; otherwise for all
      $\sigma \in \Sigma - \{*\}, |\{q''|(q,q',\sigma,q'') \in \delta_r\}|
      \leq 1$, and
  \end{itemize}
\item For all $(q,\sigma,q') \in \delta_i, \sigma \neq \epsilon$,

 for all $(q,\sigma,q') \in \delta_c, \sigma \neq \epsilon$,  and 

 for all $(q,q',\sigma,q'') \in \delta_r, \sigma \neq \epsilon$.\\

\end{enumerate}

If an NWA is not deterministic, then it is \textbf{non-deterministic}.
\end{definition}

Consider an example of determinizing a simple nondeterministic NWA, the NWA
shown in Figure \ref{Fig:Det1}.  The deterministic NWA is computed by a
generalization of the classical subset construction.  Instead of the states
in the determinized NWA being subsets of the original NWA, states of the
determinized NWA are sets of state pairs (i.e., binary relations on states)
\cite{JACM:AM2009}.  To support determinization, the library provides class
\texttt{BinaryRelation}, which is a set of \texttt{Key} pairs.  The resulting
NWA is shown in Figure \ref{Fig:Det2}.

\begin{figure}[p]
  \centering
    \includegraphics[width=12cm]{Figures/Figure16}
  \caption{Simple nondeterministic NWA.}
  \label{Fig:Det1}
\end{figure}


\begin{figure}[p]
  \centering
    \includegraphics[width=16cm]{Figures/Figure17}
    \caption{The NWA resulting from determinizing the NWA in Figure
      \ref{Fig:Det1}. As mentioned in the text, states in the determinized
      NWA are relations on the states in the original NWA. For example, state
      1 above corresponds to the relation $\{$(Start,Stuck), (Call,Stuck),
      (Entry1,Stuck), (Entry2,Exit2), (State1,Stuck), (State2,Stuck),
      (Exit1,Stuck), (Exit2,Stuck), (Return,Stuck), (Fishish,Stuck),
      (Stuck,Stuck)$\}$.}
 
  \label{Fig:Det2}
\end{figure}


Client information is generated through the use of the helper method
\texttt{mergeClientInfo}, but can be altered through the use of the helper
methods \texttt{mergeClientInfoInternal}, \texttt{mergeClientInfoCall}, and
\texttt{mergeClientInfoReturn}, which are invoked by \texttt{determinize} as
transitions of the three kinds involving the associated state are added.  The
default behavior of \texttt{mergeClientInfo} is that the \texttt{ClientInfo}
associated with the resulting state is \texttt{null}.  The default behavior
of \texttt{mergeClientInfoInternal}, \texttt{mergeClientInfoCall}, and
\texttt{mergeClientInfoReturn} is to make no changes to the the
\texttt{ClientInfo}.  These methods can be overridden to specify alternative
behaviors.  As determinization is performed, \texttt{mergeClientInfo} is
called each time a new state is created.  Then, as each transition is added,
\texttt{mergeClientInfoInternal}, \texttt{mergeClientInfoCall}, or
\texttt{mergeClientInfoReturn} is called (depending on the type of transition
being added) to update the \texttt{ClientInfo} associated with the target
state of the transition being added. \\

\noindent The following operations are methods of class NWA and are intended
to be overridden to customize behavior:

\begin{description}

  \item\texttt{void mergeClientInfo( ref\_ptr<NWA> first,\\ \hspace*{3.25cm}
    BinaryRelation const\& binRel,\\ \hspace*{3.25cm} St resSt,
    ref\_ptr<ClientInfo>\& resCI )} \nopagebreak

    Computes the client information that should be associated with the given state.

  \item\texttt{void mergeClientInfoInternal( ref\_ptr<NWA> first,\nopagebreak
    \\ \hspace*{3.25cm} BinaryRelation const\& binRelSource,\nopagebreak
    \\ \hspace*{3.25cm} BinaryRelation const\& binRelTarget, \nopagebreak
    \\ \hspace*{3.25cm} Key sourceSt, Key resSym, Key resSt, \nopagebreak
    \\ \hspace*{3.25cm} ref\_ptr<ClientInfo>\& resCI )} \nopagebreak

    Alters the client information associated with \texttt{resSt} given the
    details of the internal transition to be added to the NWA.

  \item\texttt{void mergeClientInfoCall( ref\_ptr<NWA>
    first,\\ \hspace*{3.25cm} BinaryRelation const\&
    binRelCall,\\ \hspace*{3.25cm} BinaryRelation const\&
    binRelEntry,\\ \hspace*{3.25cm} Key callSt, Key resSym, Key
    resSt,\\ \hspace*{3.25cm} ref\_ptr<ClientInfo>\& resCI )} \nopagebreak

    Alters the client information associated with \texttt{resSt} given the
    details of the call transition to be added to the NWA.

  \item\texttt{void mergeClientInfoReturn( ref\_ptr<NWA>
    first,\\ \hspace*{3.25cm} BinaryRelation const\&
    binRelExit,\\ \hspace*{3.25cm} BinaryRelation const\&
    binRelCall,\\ \hspace*{3.25cm} BinaryRelation const\&
    binRelReturn,\\ \hspace*{3.25cm} Key exitSt, Key callSt, Key
    resSym,\\ \hspace*{3.25cm} Key resSt, ref\_ptr<ClientInfo>\& resCI )}
    \nopagebreak

    Alters the client information associated with \texttt{resSt} given the
    details of the return transition to be added to the NWA. \\

\end{description}

%Consider the slightly more complex determinization of the NWA shown in Figure \ref{Fig:Det3}.  The resulting NWA is shown in Figure \ref{Fig:Det4}.

%\begin{figure}[htbp]
%  \centering
%    \includegraphics[angle=270,width=12cm]{Figures/Figure18.pdf}
%  \caption{Complex nondeterministic NWA.}
%  \label{Fig:Det3}
%\end{figure}

%\begin{figure}[htbp]
%  \centering
%    \includegraphics[angle=270,width=12cm]{Figures/Figure19.pdf}
%  \caption{The NWA resulting from determinizing the NWA in Figure \ref{Fig:Det3}.}
%  \label{Fig:Det4}
%\end{figure}

\subsection{Complement}
\label{Se:Complement}

The complement is performed by first determinizing the NWA and then
complementing the final-state set of the determinized NWA.  The NWA resulting
from performing the complement of the NWA shown in Figure \ref{Fig:Det1} is
shown in Figure \ref{Fig:Comp1}.

\begin{figure}[p]
  \centering
    \includegraphics[width=12cm]{Figures/Figure20}
  \caption{The complement of the NWA in Figure \ref{Fig:Det1} (the
    determinization of which is shown in Figure \ref{Fig:Det2}).}
  \label{Fig:Comp1}
\end{figure}

Because all non-final states (including the stuck state) become final states
in the process of complementation, all implicit transitions are materialized
and the resulting NWA is of type 2.  Client information is copied directly
from the determinization of the component NWA using the \texttt{ClientInfo}
copy constructor.

